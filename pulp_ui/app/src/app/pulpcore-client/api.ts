/* tslint:disable */
/* eslint-disable */
/**
 * Pulp 3 API
 * Fetch, Upload, Organize, and Distribute Software Packages
 *
 * The version of the OpenAPI document: v3
 * Contact: pulp-list@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Serializer for AccessPolicy.
 * @export
 * @interface AccessPolicy
 */
export interface AccessPolicy {
    /**
     * List of callables that define the new permissions to be created for new objects.
     * @type {Array<object>}
     * @memberof AccessPolicy
     */
    permissions_assignment: Array<object>;
    /**
     * List of policy statements defining the policy.
     * @type {Array<object>}
     * @memberof AccessPolicy
     */
    statements: Array<object>;
}
/**
 * Serializer for AccessPolicy.
 * @export
 * @interface AccessPolicyResponse
 */
export interface AccessPolicyResponse {
    /**
     * 
     * @type {string}
     * @memberof AccessPolicyResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof AccessPolicyResponse
     */
    pulp_created?: string;
    /**
     * List of callables that define the new permissions to be created for new objects.
     * @type {Array<object>}
     * @memberof AccessPolicyResponse
     */
    permissions_assignment: Array<object>;
    /**
     * List of policy statements defining the policy.
     * @type {Array<object>}
     * @memberof AccessPolicyResponse
     */
    statements: Array<object>;
    /**
     * The name of ViewSet this AccessPolicy authorizes.
     * @type {string}
     * @memberof AccessPolicyResponse
     */
    viewset_name?: string;
    /**
     * True if the AccessPolicy has been user-modified. False otherwise.
     * @type {boolean}
     * @memberof AccessPolicyResponse
     */
    customized?: boolean;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface ArtifactResponse
 */
export interface ArtifactResponse {
    /**
     * 
     * @type {string}
     * @memberof ArtifactResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof ArtifactResponse
     */
    pulp_created?: string;
    /**
     * The stored file.
     * @type {string}
     * @memberof ArtifactResponse
     */
    file: string;
    /**
     * The size of the file in bytes.
     * @type {number}
     * @memberof ArtifactResponse
     */
    size?: number;
    /**
     * The MD5 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    md5?: string | null;
    /**
     * The SHA-1 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha1?: string | null;
    /**
     * The SHA-224 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha224?: string | null;
    /**
     * The SHA-256 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha256?: string | null;
    /**
     * The SHA-384 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha384?: string | null;
    /**
     * The SHA-512 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha512?: string | null;
}
/**
 * Serializer for asynchronous operations.
 * @export
 * @interface AsyncOperationResponse
 */
export interface AsyncOperationResponse {
    /**
     * The href of the task.
     * @type {string}
     * @memberof AsyncOperationResponse
     */
    task: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface ContentAppStatusResponse
 */
export interface ContentAppStatusResponse {
    /**
     * The name of the worker.
     * @type {string}
     * @memberof ContentAppStatusResponse
     */
    name?: string;
    /**
     * Timestamp of the last time the worker talked to the service.
     * @type {string}
     * @memberof ContentAppStatusResponse
     */
    last_heartbeat?: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface ContentGuardResponse
 */
export interface ContentGuardResponse {
    /**
     * 
     * @type {string}
     * @memberof ContentGuardResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof ContentGuardResponse
     */
    pulp_created?: string;
    /**
     * The unique name.
     * @type {string}
     * @memberof ContentGuardResponse
     */
    name: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof ContentGuardResponse
     */
    description?: string | null;
}
/**
 * Serializer for the RepositoryVersion content summary
 * @export
 * @interface ContentSummaryResponse
 */
export interface ContentSummaryResponse {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummaryResponse
     */
    added: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummaryResponse
     */
    removed: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummaryResponse
     */
    present: { [key: string]: object; };
}
/**
 * Serializer for the database connection information
 * @export
 * @interface DatabaseConnectionResponse
 */
export interface DatabaseConnectionResponse {
    /**
     * Info about whether the app can connect to the database
     * @type {boolean}
     * @memberof DatabaseConnectionResponse
     */
    connected: boolean;
}
/**
 * Results from evaluating a proposed parameter to a PulpImport call.
 * @export
 * @interface EvaluationResponse
 */
export interface EvaluationResponse {
    /**
     * Parameter value being evaluated.
     * @type {string}
     * @memberof EvaluationResponse
     */
    context: string;
    /**
     * True if evaluation passed, false otherwise.
     * @type {boolean}
     * @memberof EvaluationResponse
     */
    is_valid: boolean;
    /**
     * Messages describing results of all evaluations done. May be an empty list.
     * @type {Array<string>}
     * @memberof EvaluationResponse
     */
    messages: Array<string>;
}
/**
 * Serializer for FilesystemExports.
 * @export
 * @interface FilesystemExport
 */
export interface FilesystemExport {
    /**
     * A URI of the task that ran the Export.
     * @type {string}
     * @memberof FilesystemExport
     */
    task?: string | null;
    /**
     * A URI of the publication to be exported.
     * @type {string}
     * @memberof FilesystemExport
     */
    publication?: string;
    /**
     * A URI of the repository version export.
     * @type {string}
     * @memberof FilesystemExport
     */
    repository_version?: string;
}
/**
 * Serializer for FilesystemExports.
 * @export
 * @interface FilesystemExportResponse
 */
export interface FilesystemExportResponse {
    /**
     * 
     * @type {string}
     * @memberof FilesystemExportResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FilesystemExportResponse
     */
    pulp_created?: string;
    /**
     * A URI of the task that ran the Export.
     * @type {string}
     * @memberof FilesystemExportResponse
     */
    task?: string | null;
    /**
     * Resources that were exported.
     * @type {Array<string>}
     * @memberof FilesystemExportResponse
     */
    exported_resources?: Array<string>;
    /**
     * Any additional parameters that were used to create the export.
     * @type {object}
     * @memberof FilesystemExportResponse
     */
    params?: object;
}
/**
 * Serializer for FilesystemExporters.
 * @export
 * @interface FilesystemExporter
 */
export interface FilesystemExporter {
    /**
     * Unique name of the file system exporter.
     * @type {string}
     * @memberof FilesystemExporter
     */
    name: string;
    /**
     * File system location to export to.
     * @type {string}
     * @memberof FilesystemExporter
     */
    path: string;
    /**
     * Method of exporting
     * @type {MethodEnum}
     * @memberof FilesystemExporter
     */
    method?: MethodEnum;
}
/**
 * Serializer for FilesystemExporters.
 * @export
 * @interface FilesystemExporterResponse
 */
export interface FilesystemExporterResponse {
    /**
     * 
     * @type {string}
     * @memberof FilesystemExporterResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FilesystemExporterResponse
     */
    pulp_created?: string;
    /**
     * Unique name of the file system exporter.
     * @type {string}
     * @memberof FilesystemExporterResponse
     */
    name: string;
    /**
     * File system location to export to.
     * @type {string}
     * @memberof FilesystemExporterResponse
     */
    path: string;
    /**
     * Method of exporting
     * @type {MethodEnum}
     * @memberof FilesystemExporterResponse
     */
    method?: MethodEnum;
}
/**
 * Serializer for Group.
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * Name
     * @type {string}
     * @memberof Group
     */
    name: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface GroupProgressReportResponse
 */
export interface GroupProgressReportResponse {
    /**
     * The message shown to the user for the group progress report.
     * @type {string}
     * @memberof GroupProgressReportResponse
     */
    message?: string;
    /**
     * Identifies the type of group progress report\'.
     * @type {string}
     * @memberof GroupProgressReportResponse
     */
    code?: string;
    /**
     * The total count of items.
     * @type {number}
     * @memberof GroupProgressReportResponse
     */
    total?: number;
    /**
     * The count of items already processed. Defaults to 0.
     * @type {number}
     * @memberof GroupProgressReportResponse
     */
    done?: number;
    /**
     * The suffix to be shown with the group progress report.
     * @type {string}
     * @memberof GroupProgressReportResponse
     */
    suffix?: string | null;
}
/**
 * Serializer for Group.
 * @export
 * @interface GroupResponse
 */
export interface GroupResponse {
    /**
     * Name
     * @type {string}
     * @memberof GroupResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GroupResponse
     */
    pulp_href?: string;
    /**
     * 
     * @type {number}
     * @memberof GroupResponse
     */
    id?: number;
}
/**
 * Serializer for Users that belong to a Group.
 * @export
 * @interface GroupUser
 */
export interface GroupUser {
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof GroupUser
     */
    username: string;
}
/**
 * Serializer for Users that belong to a Group.
 * @export
 * @interface GroupUserResponse
 */
export interface GroupUserResponse {
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof GroupUserResponse
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof GroupUserResponse
     */
    pulp_href?: string;
}
/**
 * Serializer for Imports.
 * @export
 * @interface ImportResponse
 */
export interface ImportResponse {
    /**
     * 
     * @type {string}
     * @memberof ImportResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof ImportResponse
     */
    pulp_created?: string;
    /**
     * A URI of the Task that ran the Import.
     * @type {string}
     * @memberof ImportResponse
     */
    task: string;
    /**
     * Any parameters that were used to create the import.
     * @type {object}
     * @memberof ImportResponse
     */
    params: object;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum MethodEnum {
    Write = 'write',
    Hardlink = 'hardlink',
    Symlink = 'symlink'
}

/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface MinimalTaskResponse
 */
export interface MinimalTaskResponse {
    /**
     * 
     * @type {string}
     * @memberof MinimalTaskResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof MinimalTaskResponse
     */
    pulp_created?: string;
    /**
     * The name of task.
     * @type {string}
     * @memberof MinimalTaskResponse
     */
    name: string;
    /**
     * The current state of the task. The possible values include: \'waiting\', \'skipped\', \'running\', \'completed\', \'failed\', \'canceled\' and \'canceling\'.
     * @type {string}
     * @memberof MinimalTaskResponse
     */
    state?: string;
    /**
     * Timestamp of the when this task started execution.
     * @type {string}
     * @memberof MinimalTaskResponse
     */
    started_at?: string;
    /**
     * Timestamp of the when this task stopped execution.
     * @type {string}
     * @memberof MinimalTaskResponse
     */
    finished_at?: string;
    /**
     * The worker associated with this task. This field is empty if a worker is not yet assigned.
     * @type {string}
     * @memberof MinimalTaskResponse
     */
    worker?: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface MultipleArtifactContentResponse
 */
export interface MultipleArtifactContentResponse {
    /**
     * 
     * @type {string}
     * @memberof MultipleArtifactContentResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof MultipleArtifactContentResponse
     */
    pulp_created?: string;
    /**
     * A dict mapping relative paths inside the Content to the correspondingArtifact URLs. E.g.: {\'relative/path\': \'/artifacts/1/\'
     * @type {object}
     * @memberof MultipleArtifactContentResponse
     */
    artifacts: object;
}
/**
 * 
 * @export
 * @interface OrphansCleanup
 */
export interface OrphansCleanup {
    /**
     * Will delete specified content and associated Artifacts if they are orphans.
     * @type {Array<any>}
     * @memberof OrphansCleanup
     */
    content_hrefs?: Array<any>;
    /**
     * The time in minutes for how long Pulp will hold orphan Content and Artifacts before they become candidates for deletion by this orphan cleanup task. This should ideally be longer than your longest running task otherwise any content created during that task could be cleaned up before the task finishes. If not specified, default is used from settings which is 1440 minutes (24 hours)
     * @type {number}
     * @memberof OrphansCleanup
     */
    orphan_protection_time?: number | null;
}
/**
 * 
 * @export
 * @interface PaginatedAccessPolicyResponseList
 */
export interface PaginatedAccessPolicyResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAccessPolicyResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAccessPolicyResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAccessPolicyResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<AccessPolicyResponse>}
     * @memberof PaginatedAccessPolicyResponseList
     */
    results?: Array<AccessPolicyResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedArtifactResponseList
 */
export interface PaginatedArtifactResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedArtifactResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedArtifactResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedArtifactResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ArtifactResponse>}
     * @memberof PaginatedArtifactResponseList
     */
    results?: Array<ArtifactResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedContentGuardResponseList
 */
export interface PaginatedContentGuardResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedContentGuardResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedContentGuardResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedContentGuardResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ContentGuardResponse>}
     * @memberof PaginatedContentGuardResponseList
     */
    results?: Array<ContentGuardResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedFilesystemExportResponseList
 */
export interface PaginatedFilesystemExportResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFilesystemExportResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFilesystemExportResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFilesystemExportResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FilesystemExportResponse>}
     * @memberof PaginatedFilesystemExportResponseList
     */
    results?: Array<FilesystemExportResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedFilesystemExporterResponseList
 */
export interface PaginatedFilesystemExporterResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFilesystemExporterResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFilesystemExporterResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFilesystemExporterResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FilesystemExporterResponse>}
     * @memberof PaginatedFilesystemExporterResponseList
     */
    results?: Array<FilesystemExporterResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedGroupResponseList
 */
export interface PaginatedGroupResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGroupResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGroupResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGroupResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<GroupResponse>}
     * @memberof PaginatedGroupResponseList
     */
    results?: Array<GroupResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedGroupUserResponseList
 */
export interface PaginatedGroupUserResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGroupUserResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGroupUserResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGroupUserResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<GroupUserResponse>}
     * @memberof PaginatedGroupUserResponseList
     */
    results?: Array<GroupUserResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedImportResponseList
 */
export interface PaginatedImportResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedImportResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedImportResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedImportResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ImportResponse>}
     * @memberof PaginatedImportResponseList
     */
    results?: Array<ImportResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedMultipleArtifactContentResponseList
 */
export interface PaginatedMultipleArtifactContentResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMultipleArtifactContentResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMultipleArtifactContentResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMultipleArtifactContentResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<MultipleArtifactContentResponse>}
     * @memberof PaginatedMultipleArtifactContentResponseList
     */
    results?: Array<MultipleArtifactContentResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedPermissionResponseList
 */
export interface PaginatedPermissionResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPermissionResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPermissionResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPermissionResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PermissionResponse>}
     * @memberof PaginatedPermissionResponseList
     */
    results?: Array<PermissionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedPublicationResponseList
 */
export interface PaginatedPublicationResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPublicationResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPublicationResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPublicationResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PublicationResponse>}
     * @memberof PaginatedPublicationResponseList
     */
    results?: Array<PublicationResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedPulpExportResponseList
 */
export interface PaginatedPulpExportResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPulpExportResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPulpExportResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPulpExportResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PulpExportResponse>}
     * @memberof PaginatedPulpExportResponseList
     */
    results?: Array<PulpExportResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedPulpExporterResponseList
 */
export interface PaginatedPulpExporterResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPulpExporterResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPulpExporterResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPulpExporterResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PulpExporterResponse>}
     * @memberof PaginatedPulpExporterResponseList
     */
    results?: Array<PulpExporterResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedPulpImporterResponseList
 */
export interface PaginatedPulpImporterResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPulpImporterResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPulpImporterResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPulpImporterResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PulpImporterResponse>}
     * @memberof PaginatedPulpImporterResponseList
     */
    results?: Array<PulpImporterResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedRBACContentGuardResponseList
 */
export interface PaginatedRBACContentGuardResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRBACContentGuardResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRBACContentGuardResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRBACContentGuardResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RBACContentGuardResponse>}
     * @memberof PaginatedRBACContentGuardResponseList
     */
    results?: Array<RBACContentGuardResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedRepositoryResponseList
 */
export interface PaginatedRepositoryResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRepositoryResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRepositoryResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRepositoryResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RepositoryResponse>}
     * @memberof PaginatedRepositoryResponseList
     */
    results?: Array<RepositoryResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedRepositoryVersionResponseList
 */
export interface PaginatedRepositoryVersionResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RepositoryVersionResponse>}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    results?: Array<RepositoryVersionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedSigningServiceResponseList
 */
export interface PaginatedSigningServiceResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSigningServiceResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSigningServiceResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSigningServiceResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SigningServiceResponse>}
     * @memberof PaginatedSigningServiceResponseList
     */
    results?: Array<SigningServiceResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedTaskGroupResponseList
 */
export interface PaginatedTaskGroupResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTaskGroupResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTaskGroupResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTaskGroupResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<TaskGroupResponse>}
     * @memberof PaginatedTaskGroupResponseList
     */
    results?: Array<TaskGroupResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedTaskResponseList
 */
export interface PaginatedTaskResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTaskResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTaskResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTaskResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<TaskResponse>}
     * @memberof PaginatedTaskResponseList
     */
    results?: Array<TaskResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedUploadResponseList
 */
export interface PaginatedUploadResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUploadResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUploadResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUploadResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UploadResponse>}
     * @memberof PaginatedUploadResponseList
     */
    results?: Array<UploadResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedUserResponseList
 */
export interface PaginatedUserResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof PaginatedUserResponseList
     */
    results?: Array<UserResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedWorkerResponseList
 */
export interface PaginatedWorkerResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedWorkerResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWorkerResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWorkerResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<WorkerResponse>}
     * @memberof PaginatedWorkerResponseList
     */
    results?: Array<WorkerResponse>;
}
/**
 * Serializer for AccessPolicy.
 * @export
 * @interface PatchedAccessPolicy
 */
export interface PatchedAccessPolicy {
    /**
     * List of callables that define the new permissions to be created for new objects.
     * @type {Array<object>}
     * @memberof PatchedAccessPolicy
     */
    permissions_assignment?: Array<object>;
    /**
     * List of policy statements defining the policy.
     * @type {Array<object>}
     * @memberof PatchedAccessPolicy
     */
    statements?: Array<object>;
}
/**
 * Serializer for FilesystemExporters.
 * @export
 * @interface PatchedFilesystemExporter
 */
export interface PatchedFilesystemExporter {
    /**
     * Unique name of the file system exporter.
     * @type {string}
     * @memberof PatchedFilesystemExporter
     */
    name?: string;
    /**
     * File system location to export to.
     * @type {string}
     * @memberof PatchedFilesystemExporter
     */
    path?: string;
    /**
     * Method of exporting
     * @type {MethodEnum}
     * @memberof PatchedFilesystemExporter
     */
    method?: MethodEnum;
}
/**
 * Serializer for Group.
 * @export
 * @interface PatchedGroup
 */
export interface PatchedGroup {
    /**
     * Name
     * @type {string}
     * @memberof PatchedGroup
     */
    name?: string;
}
/**
 * Serializer for pulp exporters.
 * @export
 * @interface PatchedPulpExporter
 */
export interface PatchedPulpExporter {
    /**
     * Unique name of the file system exporter.
     * @type {string}
     * @memberof PatchedPulpExporter
     */
    name?: string;
    /**
     * File system directory to store exported tar.gzs.
     * @type {string}
     * @memberof PatchedPulpExporter
     */
    path?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedPulpExporter
     */
    repositories?: Array<string>;
    /**
     * Last attempted export for this PulpExporter
     * @type {string}
     * @memberof PatchedPulpExporter
     */
    last_export?: string | null;
}
/**
 * Serializer for PulpImporters.
 * @export
 * @interface PatchedPulpImporter
 */
export interface PatchedPulpImporter {
    /**
     * Unique name of the Importer.
     * @type {string}
     * @memberof PatchedPulpImporter
     */
    name?: string;
    /**
     * Mapping of repo names in an export file to the repo names in Pulp. For example, if the export has a repo named \'foo\' and the repo to import content into was \'bar\', the mapping would be \"{\'foo\': \'bar\'}\".
     * @type {{ [key: string]: string; }}
     * @memberof PatchedPulpImporter
     */
    repo_mapping?: { [key: string]: string; };
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface PatchedRBACContentGuard
 */
export interface PatchedRBACContentGuard {
    /**
     * The unique name.
     * @type {string}
     * @memberof PatchedRBACContentGuard
     */
    name?: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof PatchedRBACContentGuard
     */
    description?: string | null;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface PatchedTaskCancel
 */
export interface PatchedTaskCancel {
    /**
     * The desired state of the task. Only \'canceled\' is accepted.
     * @type {string}
     * @memberof PatchedTaskCancel
     */
    state?: string;
}
/**
 * Serializer for User/Group object permission.
 * @export
 * @interface PermissionResponse
 */
export interface PermissionResponse {
    /**
     * 
     * @type {string}
     * @memberof PermissionResponse
     */
    pulp_href?: string;
    /**
     * 
     * @type {number}
     * @memberof PermissionResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PermissionResponse
     */
    permission?: string;
    /**
     * Content object.
     * @type {string}
     * @memberof PermissionResponse
     */
    obj?: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface ProgressReportResponse
 */
export interface ProgressReportResponse {
    /**
     * The message shown to the user for the progress report.
     * @type {string}
     * @memberof ProgressReportResponse
     */
    message?: string;
    /**
     * Identifies the type of progress report\'.
     * @type {string}
     * @memberof ProgressReportResponse
     */
    code?: string;
    /**
     * The current state of the progress report. The possible values are: \'waiting\', \'skipped\', \'running\', \'completed\', \'failed\', \'canceled\' and \'canceling\'. The default is \'waiting\'.
     * @type {string}
     * @memberof ProgressReportResponse
     */
    state?: string;
    /**
     * The total count of items.
     * @type {number}
     * @memberof ProgressReportResponse
     */
    total?: number;
    /**
     * The count of items already processed. Defaults to 0.
     * @type {number}
     * @memberof ProgressReportResponse
     */
    done?: number;
    /**
     * The suffix to be shown with the progress report.
     * @type {string}
     * @memberof ProgressReportResponse
     */
    suffix?: string | null;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface PublicationResponse
 */
export interface PublicationResponse {
    /**
     * 
     * @type {string}
     * @memberof PublicationResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof PublicationResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationResponse
     */
    repository_version?: string;
    /**
     * A URI of the repository to be published.
     * @type {string}
     * @memberof PublicationResponse
     */
    repository?: string;
}
/**
 * Serializer for PulpExports.
 * @export
 * @interface PulpExport
 */
export interface PulpExport {
    /**
     * A URI of the task that ran the Export.
     * @type {string}
     * @memberof PulpExport
     */
    task?: string | null;
    /**
     * Do a Full (true) or Incremental (false) export.
     * @type {boolean}
     * @memberof PulpExport
     */
    full?: boolean;
    /**
     * Generate report on what would be exported and disk-space required.
     * @type {boolean}
     * @memberof PulpExport
     */
    dry_run?: boolean;
    /**
     * List of explicit repo-version hrefs to export (replaces current_version).
     * @type {Array<string>}
     * @memberof PulpExport
     */
    versions?: Array<string>;
    /**
     * Chunk export-tarfile into pieces of chunk_size bytes. Recognizes units of B/KB/MB/GB/TB. A chunk has a maximum size of 1TB.
     * @type {string}
     * @memberof PulpExport
     */
    chunk_size?: string;
    /**
     * List of explicit last-exported-repo-version hrefs (replaces last_export).
     * @type {Array<string>}
     * @memberof PulpExport
     */
    start_versions?: Array<string>;
}
/**
 * Serializer for PulpExports.
 * @export
 * @interface PulpExportResponse
 */
export interface PulpExportResponse {
    /**
     * 
     * @type {string}
     * @memberof PulpExportResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof PulpExportResponse
     */
    pulp_created?: string;
    /**
     * A URI of the task that ran the Export.
     * @type {string}
     * @memberof PulpExportResponse
     */
    task?: string | null;
    /**
     * Resources that were exported.
     * @type {Array<string>}
     * @memberof PulpExportResponse
     */
    exported_resources?: Array<string>;
    /**
     * Any additional parameters that were used to create the export.
     * @type {object}
     * @memberof PulpExportResponse
     */
    params?: object;
    /**
     * Dictionary of filename: sha256hash entries for export-output-file(s)
     * @type {object}
     * @memberof PulpExportResponse
     */
    output_file_info?: object;
    /**
     * Filename and sha256-checksum of table-of-contents for this export
     * @type {object}
     * @memberof PulpExportResponse
     */
    toc_info?: object;
}
/**
 * Serializer for pulp exporters.
 * @export
 * @interface PulpExporter
 */
export interface PulpExporter {
    /**
     * Unique name of the file system exporter.
     * @type {string}
     * @memberof PulpExporter
     */
    name: string;
    /**
     * File system directory to store exported tar.gzs.
     * @type {string}
     * @memberof PulpExporter
     */
    path: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PulpExporter
     */
    repositories: Array<string>;
    /**
     * Last attempted export for this PulpExporter
     * @type {string}
     * @memberof PulpExporter
     */
    last_export?: string | null;
}
/**
 * Serializer for pulp exporters.
 * @export
 * @interface PulpExporterResponse
 */
export interface PulpExporterResponse {
    /**
     * 
     * @type {string}
     * @memberof PulpExporterResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof PulpExporterResponse
     */
    pulp_created?: string;
    /**
     * Unique name of the file system exporter.
     * @type {string}
     * @memberof PulpExporterResponse
     */
    name: string;
    /**
     * File system directory to store exported tar.gzs.
     * @type {string}
     * @memberof PulpExporterResponse
     */
    path: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PulpExporterResponse
     */
    repositories: Array<string>;
    /**
     * Last attempted export for this PulpExporter
     * @type {string}
     * @memberof PulpExporterResponse
     */
    last_export?: string | null;
}
/**
 * Serializer for call to import into Pulp.
 * @export
 * @interface PulpImport
 */
export interface PulpImport {
    /**
     * Path to export that will be imported.
     * @type {string}
     * @memberof PulpImport
     */
    path?: string;
    /**
     * Path to a table-of-contents file describing chunks to be validated, reassembled, and imported.
     * @type {string}
     * @memberof PulpImport
     */
    toc?: string;
}
/**
 * Check validity of provided import-options.  Provides the ability to check that an import is \'sane\' without having to actually create an importer.
 * @export
 * @interface PulpImportCheck
 */
export interface PulpImportCheck {
    /**
     * Path to export-tar-gz that will be imported.
     * @type {string}
     * @memberof PulpImportCheck
     */
    path?: string;
    /**
     * Path to a table-of-contents file describing chunks to be validated, reassembled, and imported.
     * @type {string}
     * @memberof PulpImportCheck
     */
    toc?: string;
    /**
     * Mapping of repo names in an export file to the repo names in Pulp. For example, if the export has a repo named \'foo\' and the repo to import content into was \'bar\', the mapping would be \"{\'foo\': \'bar\'}\".
     * @type {string}
     * @memberof PulpImportCheck
     */
    repo_mapping?: string;
}
/**
 * Return the response to a PulpImport import-check call.
 * @export
 * @interface PulpImportCheckResponse
 */
export interface PulpImportCheckResponse {
    /**
     * Evaluation of proposed \'toc\' file for PulpImport
     * @type {EvaluationResponse}
     * @memberof PulpImportCheckResponse
     */
    toc?: EvaluationResponse;
    /**
     * Evaluation of proposed \'path\' file for PulpImport
     * @type {EvaluationResponse}
     * @memberof PulpImportCheckResponse
     */
    path?: EvaluationResponse;
    /**
     * Evaluation of proposed \'repo_mapping\' file for PulpImport
     * @type {EvaluationResponse}
     * @memberof PulpImportCheckResponse
     */
    repo_mapping?: EvaluationResponse;
}
/**
 * Serializer for PulpImporters.
 * @export
 * @interface PulpImporter
 */
export interface PulpImporter {
    /**
     * Unique name of the Importer.
     * @type {string}
     * @memberof PulpImporter
     */
    name: string;
    /**
     * Mapping of repo names in an export file to the repo names in Pulp. For example, if the export has a repo named \'foo\' and the repo to import content into was \'bar\', the mapping would be \"{\'foo\': \'bar\'}\".
     * @type {{ [key: string]: string; }}
     * @memberof PulpImporter
     */
    repo_mapping?: { [key: string]: string; };
}
/**
 * Serializer for PulpImporters.
 * @export
 * @interface PulpImporterResponse
 */
export interface PulpImporterResponse {
    /**
     * 
     * @type {string}
     * @memberof PulpImporterResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof PulpImporterResponse
     */
    pulp_created?: string;
    /**
     * Unique name of the Importer.
     * @type {string}
     * @memberof PulpImporterResponse
     */
    name: string;
    /**
     * Mapping of repo names in an export file to the repo names in Pulp. For example, if the export has a repo named \'foo\' and the repo to import content into was \'bar\', the mapping would be \"{\'foo\': \'bar\'}\".
     * @type {{ [key: string]: string; }}
     * @memberof PulpImporterResponse
     */
    repo_mapping?: { [key: string]: string; };
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RBACContentGuard
 */
export interface RBACContentGuard {
    /**
     * The unique name.
     * @type {string}
     * @memberof RBACContentGuard
     */
    name: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof RBACContentGuard
     */
    description?: string | null;
}
/**
 * 
 * @export
 * @interface RBACContentGuardPermission
 */
export interface RBACContentGuardPermission {
    /**
     * 
     * @type {Array<any>}
     * @memberof RBACContentGuardPermission
     */
    usernames?: Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof RBACContentGuardPermission
     */
    groupnames?: Array<any>;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RBACContentGuardResponse
 */
export interface RBACContentGuardResponse {
    /**
     * 
     * @type {string}
     * @memberof RBACContentGuardResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RBACContentGuardResponse
     */
    pulp_created?: string;
    /**
     * The unique name.
     * @type {string}
     * @memberof RBACContentGuardResponse
     */
    name: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof RBACContentGuardResponse
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RBACContentGuardResponse
     */
    users?: string;
    /**
     * 
     * @type {string}
     * @memberof RBACContentGuardResponse
     */
    groups?: string;
}
/**
 * Serializer for reclaim disk space operation.
 * @export
 * @interface ReclaimSpace
 */
export interface ReclaimSpace {
    /**
     * Will reclaim space for the specified list of repos.
     * @type {Array<any>}
     * @memberof ReclaimSpace
     */
    repo_hrefs: Array<any>;
    /**
     * Will exclude repo versions from space reclaim.
     * @type {Array<string>}
     * @memberof ReclaimSpace
     */
    repo_versions_keeplist?: Array<string>;
}
/**
 * Serializer for information about the Redis connection
 * @export
 * @interface RedisConnectionResponse
 */
export interface RedisConnectionResponse {
    /**
     * Info about whether the app can connect to Redis
     * @type {boolean}
     * @memberof RedisConnectionResponse
     */
    connected: boolean;
}
/**
 * 
 * @export
 * @interface Repair
 */
export interface Repair {
    /**
     * Will verify that the checksum of all stored files matches what saved in the database. Otherwise only the existence of the files will be checked. Enabled by default
     * @type {boolean}
     * @memberof Repair
     */
    verify_checksums?: boolean;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RepositoryResponse
 */
export interface RepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof RepositoryResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RepositoryResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryResponse
     */
    versions_href?: string;
    /**
     * 
     * @type {object}
     * @memberof RepositoryResponse
     */
    pulp_labels?: object;
    /**
     * 
     * @type {string}
     * @memberof RepositoryResponse
     */
    latest_version_href?: string;
    /**
     * A unique name for this repository.
     * @type {string}
     * @memberof RepositoryResponse
     */
    name: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof RepositoryResponse
     */
    description?: string | null;
    /**
     * Retain X versions of the repository. Default is null which retains all versions. This is provided as a tech preview in Pulp 3 and may change in the future.
     * @type {number}
     * @memberof RepositoryResponse
     */
    retain_repo_versions?: number | null;
    /**
     * An optional remote to use by default when syncing.
     * @type {string}
     * @memberof RepositoryResponse
     */
    remote?: string | null;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RepositoryVersionResponse
 */
export interface RepositoryVersionResponse {
    /**
     * 
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {number}
     * @memberof RepositoryVersionResponse
     */
    number?: number;
    /**
     * 
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    repository?: string;
    /**
     * A repository version whose content was used as the initial set of content for this repository version
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    base_version?: string;
    /**
     * Various count summaries of the content in the version and the HREF to view them.
     * @type {ContentSummaryResponse}
     * @memberof RepositoryVersionResponse
     */
    content_summary?: ContentSummaryResponse;
}
/**
 * A serializer for the model declaring a signing service.
 * @export
 * @interface SigningServiceResponse
 */
export interface SigningServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof SigningServiceResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof SigningServiceResponse
     */
    pulp_created?: string;
    /**
     * A unique name used to recognize a script.
     * @type {string}
     * @memberof SigningServiceResponse
     */
    name: string;
    /**
     * The value of a public key used for the repository verification.
     * @type {string}
     * @memberof SigningServiceResponse
     */
    public_key: string;
    /**
     * The fingerprint of the public key.
     * @type {string}
     * @memberof SigningServiceResponse
     */
    pubkey_fingerprint: string;
    /**
     * An absolute path to a script which is going to be used for the signing.
     * @type {string}
     * @memberof SigningServiceResponse
     */
    script: string;
}
/**
 * Serializer for the status information of the app
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * Version information of Pulp components
     * @type {Array<VersionResponse>}
     * @memberof StatusResponse
     */
    versions: Array<VersionResponse>;
    /**
     * List of online workers known to the application. An online worker is actively heartbeating and can respond to new work
     * @type {Array<WorkerResponse>}
     * @memberof StatusResponse
     */
    online_workers: Array<WorkerResponse>;
    /**
     * List of online content apps known to the application. An online content app is actively heartbeating and can serve data to clients
     * @type {Array<ContentAppStatusResponse>}
     * @memberof StatusResponse
     */
    online_content_apps: Array<ContentAppStatusResponse>;
    /**
     * Database connection information
     * @type {DatabaseConnectionResponse}
     * @memberof StatusResponse
     */
    database_connection: DatabaseConnectionResponse;
    /**
     * Redis connection information
     * @type {RedisConnectionResponse}
     * @memberof StatusResponse
     */
    redis_connection?: RedisConnectionResponse;
    /**
     * Storage information
     * @type {StorageResponse}
     * @memberof StatusResponse
     */
    storage?: StorageResponse;
}
/**
 * Serializer for information about the storage system
 * @export
 * @interface StorageResponse
 */
export interface StorageResponse {
    /**
     * Total number of bytes
     * @type {number}
     * @memberof StorageResponse
     */
    total: number;
    /**
     * Number of bytes in use
     * @type {number}
     * @memberof StorageResponse
     */
    used: number;
    /**
     * Number of free bytes
     * @type {number}
     * @memberof StorageResponse
     */
    free: number;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface TaskGroupResponse
 */
export interface TaskGroupResponse {
    /**
     * 
     * @type {string}
     * @memberof TaskGroupResponse
     */
    pulp_href?: string;
    /**
     * A description of the task group.
     * @type {string}
     * @memberof TaskGroupResponse
     */
    description: string;
    /**
     * Whether all tasks have been spawned for this task group.
     * @type {boolean}
     * @memberof TaskGroupResponse
     */
    all_tasks_dispatched: boolean;
    /**
     * Number of tasks in the \'waiting\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    waiting?: number;
    /**
     * Number of tasks in the \'skipped\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    skipped?: number;
    /**
     * Number of tasks in the \'running\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    running?: number;
    /**
     * Number of tasks in the \'completed\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    completed?: number;
    /**
     * Number of tasks in the \'canceled\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    canceled?: number;
    /**
     * Number of tasks in the \'failed\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    failed?: number;
    /**
     * Number of tasks in the \'canceling\' state
     * @type {number}
     * @memberof TaskGroupResponse
     */
    canceling?: number;
    /**
     * 
     * @type {Array<GroupProgressReportResponse>}
     * @memberof TaskGroupResponse
     */
    group_progress_reports?: Array<GroupProgressReportResponse>;
    /**
     * 
     * @type {Array<MinimalTaskResponse>}
     * @memberof TaskGroupResponse
     */
    tasks?: Array<MinimalTaskResponse>;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface TaskResponse
 */
export interface TaskResponse {
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof TaskResponse
     */
    pulp_created?: string;
    /**
     * The current state of the task. The possible values include: \'waiting\', \'skipped\', \'running\', \'completed\', \'failed\', \'canceled\' and \'canceling\'.
     * @type {string}
     * @memberof TaskResponse
     */
    state?: string;
    /**
     * The name of task.
     * @type {string}
     * @memberof TaskResponse
     */
    name: string;
    /**
     * The logging correlation id associated with this task
     * @type {string}
     * @memberof TaskResponse
     */
    logging_cid: string;
    /**
     * Timestamp of the when this task started execution.
     * @type {string}
     * @memberof TaskResponse
     */
    started_at?: string;
    /**
     * Timestamp of the when this task stopped execution.
     * @type {string}
     * @memberof TaskResponse
     */
    finished_at?: string;
    /**
     * A JSON Object of a fatal error encountered during the execution of this task.
     * @type {{ [key: string]: object; }}
     * @memberof TaskResponse
     */
    error?: { [key: string]: object; };
    /**
     * The worker associated with this task. This field is empty if a worker is not yet assigned.
     * @type {string}
     * @memberof TaskResponse
     */
    worker?: string;
    /**
     * The parent task that spawned this task.
     * @type {string}
     * @memberof TaskResponse
     */
    parent_task?: string;
    /**
     * Any tasks spawned by this task.
     * @type {Array<string>}
     * @memberof TaskResponse
     */
    child_tasks?: Array<string>;
    /**
     * The task group that this task is a member of.
     * @type {string}
     * @memberof TaskResponse
     */
    task_group?: string;
    /**
     * 
     * @type {Array<ProgressReportResponse>}
     * @memberof TaskResponse
     */
    progress_reports?: Array<ProgressReportResponse>;
    /**
     * Resources created by this task.
     * @type {Array<string>}
     * @memberof TaskResponse
     */
    created_resources?: Array<string>;
    /**
     * A list of resources required by that task.
     * @type {Array<string>}
     * @memberof TaskResponse
     */
    reserved_resources_record?: Array<string>;
}
/**
 * Serializer for chunked uploads.
 * @export
 * @interface Upload
 */
export interface Upload {
    /**
     * The size of the upload in bytes.
     * @type {number}
     * @memberof Upload
     */
    size: number;
}
/**
 * A mixin for validating unknown serializers\' fields.
 * @export
 * @interface UploadChunkResponse
 */
export interface UploadChunkResponse {
    /**
     * 
     * @type {number}
     * @memberof UploadChunkResponse
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof UploadChunkResponse
     */
    size?: number;
}
/**
 * A mixin for validating unknown serializers\' fields.
 * @export
 * @interface UploadCommit
 */
export interface UploadCommit {
    /**
     * The expected sha256 checksum for the file.
     * @type {string}
     * @memberof UploadCommit
     */
    sha256: string;
}
/**
 * Serializer for chunked uploads.
 * @export
 * @interface UploadDetailResponse
 */
export interface UploadDetailResponse {
    /**
     * 
     * @type {string}
     * @memberof UploadDetailResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof UploadDetailResponse
     */
    pulp_created?: string;
    /**
     * The size of the upload in bytes.
     * @type {number}
     * @memberof UploadDetailResponse
     */
    size: number;
    /**
     * Timestamp when upload is committed.
     * @type {string}
     * @memberof UploadDetailResponse
     */
    completed?: string;
    /**
     * 
     * @type {Array<UploadChunkResponse>}
     * @memberof UploadDetailResponse
     */
    chunks?: Array<UploadChunkResponse>;
}
/**
 * Serializer for chunked uploads.
 * @export
 * @interface UploadResponse
 */
export interface UploadResponse {
    /**
     * 
     * @type {string}
     * @memberof UploadResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof UploadResponse
     */
    pulp_created?: string;
    /**
     * The size of the upload in bytes.
     * @type {number}
     * @memberof UploadResponse
     */
    size: number;
    /**
     * Timestamp when upload is committed.
     * @type {string}
     * @memberof UploadResponse
     */
    completed?: string;
}
/**
 * Serializer for Groups that belong to an User.
 * @export
 * @interface UserGroupResponse
 */
export interface UserGroupResponse {
    /**
     * Name.
     * @type {string}
     * @memberof UserGroupResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserGroupResponse
     */
    pulp_href?: string;
}
/**
 * Serializer for User.
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    pulp_href?: string;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    id?: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof UserResponse
     */
    username: string;
    /**
     * First name
     * @type {string}
     * @memberof UserResponse
     */
    first_name: string;
    /**
     * Last name
     * @type {string}
     * @memberof UserResponse
     */
    last_name: string;
    /**
     * Email address
     * @type {string}
     * @memberof UserResponse
     */
    email: string;
    /**
     * Designates whether the user can log into this admin site.
     * @type {boolean}
     * @memberof UserResponse
     */
    is_staff?: boolean;
    /**
     * Designates whether this user should be treated as active.
     * @type {boolean}
     * @memberof UserResponse
     */
    is_active?: boolean;
    /**
     * Date joined
     * @type {string}
     * @memberof UserResponse
     */
    date_joined?: string;
    /**
     * 
     * @type {Array<UserGroupResponse>}
     * @memberof UserResponse
     */
    groups?: Array<UserGroupResponse>;
}
/**
 * Serializer for the version information of Pulp components
 * @export
 * @interface VersionResponse
 */
export interface VersionResponse {
    /**
     * Name of a versioned component of Pulp
     * @type {string}
     * @memberof VersionResponse
     */
    component: string;
    /**
     * Version of the component (e.g. 3.0.0)
     * @type {string}
     * @memberof VersionResponse
     */
    version: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface WorkerResponse
 */
export interface WorkerResponse {
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof WorkerResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerResponse
     */
    pulp_href?: string;
    /**
     * The name of the worker.
     * @type {string}
     * @memberof WorkerResponse
     */
    name?: string;
    /**
     * Timestamp of the last time the worker talked to the service.
     * @type {string}
     * @memberof WorkerResponse
     */
    last_heartbeat?: string;
}

/**
 * AccessPoliciesApi - axios parameter creator
 * @export
 */
export const AccessPoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List access policys
         * @param {boolean} [customized] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [viewsetName] Filter results where viewset_name matches value
         * @param {string} [viewsetNameContains] Filter results where viewset_name contains value
         * @param {string} [viewsetNameIcontains] Filter results where viewset_name contains value
         * @param {Array<string>} [viewsetNameIn] Filter results where viewset_name is in a comma-separated list of values
         * @param {string} [viewsetNameStartswith] Filter results where viewset_name starts with value
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (customized?: boolean, limit?: number, offset?: number, ordering?: string, viewsetName?: string, viewsetNameContains?: string, viewsetNameIcontains?: string, viewsetNameIn?: Array<string>, viewsetNameStartswith?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/access_policies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (customized !== undefined) {
                localVarQueryParameter['customized'] = customized;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (viewsetName !== undefined) {
                localVarQueryParameter['viewset_name'] = viewsetName;
            }

            if (viewsetNameContains !== undefined) {
                localVarQueryParameter['viewset_name__contains'] = viewsetNameContains;
            }

            if (viewsetNameIcontains !== undefined) {
                localVarQueryParameter['viewset_name__icontains'] = viewsetNameIcontains;
            }

            if (viewsetNameIn) {
                localVarQueryParameter['viewset_name__in'] = viewsetNameIn.join(COLLECTION_FORMATS.csv);
            }

            if (viewsetNameStartswith !== undefined) {
                localVarQueryParameter['viewset_name__startswith'] = viewsetNameStartswith;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update an access policy
         * @param {string} accessPolicyHref 
         * @param {PatchedAccessPolicy} patchedAccessPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (accessPolicyHref: string, patchedAccessPolicy: PatchedAccessPolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessPolicyHref' is not null or undefined
            assertParamExists('partialUpdate', 'accessPolicyHref', accessPolicyHref)
            // verify required parameter 'patchedAccessPolicy' is not null or undefined
            assertParamExists('partialUpdate', 'patchedAccessPolicy', patchedAccessPolicy)
            const localVarPath = `{access_policy_href}`
                .replace(`{${"access_policy_href"}}`, String(accessPolicyHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAccessPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect an access policy
         * @param {string} accessPolicyHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (accessPolicyHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessPolicyHref' is not null or undefined
            assertParamExists('read', 'accessPolicyHref', accessPolicyHref)
            const localVarPath = `{access_policy_href}`
                .replace(`{${"access_policy_href"}}`, String(accessPolicyHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update an access policy
         * @param {string} accessPolicyHref 
         * @param {AccessPolicy} accessPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (accessPolicyHref: string, accessPolicy: AccessPolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessPolicyHref' is not null or undefined
            assertParamExists('update', 'accessPolicyHref', accessPolicyHref)
            // verify required parameter 'accessPolicy' is not null or undefined
            assertParamExists('update', 'accessPolicy', accessPolicy)
            const localVarPath = `{access_policy_href}`
                .replace(`{${"access_policy_href"}}`, String(accessPolicyHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessPoliciesApi - functional programming interface
 * @export
 */
export const AccessPoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessPoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List access policys
         * @param {boolean} [customized] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [viewsetName] Filter results where viewset_name matches value
         * @param {string} [viewsetNameContains] Filter results where viewset_name contains value
         * @param {string} [viewsetNameIcontains] Filter results where viewset_name contains value
         * @param {Array<string>} [viewsetNameIn] Filter results where viewset_name is in a comma-separated list of values
         * @param {string} [viewsetNameStartswith] Filter results where viewset_name starts with value
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(customized?: boolean, limit?: number, offset?: number, ordering?: string, viewsetName?: string, viewsetNameContains?: string, viewsetNameIcontains?: string, viewsetNameIn?: Array<string>, viewsetNameStartswith?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAccessPolicyResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(customized, limit, offset, ordering, viewsetName, viewsetNameContains, viewsetNameIcontains, viewsetNameIn, viewsetNameStartswith, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update an access policy
         * @param {string} accessPolicyHref 
         * @param {PatchedAccessPolicy} patchedAccessPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(accessPolicyHref: string, patchedAccessPolicy: PatchedAccessPolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(accessPolicyHref, patchedAccessPolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect an access policy
         * @param {string} accessPolicyHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(accessPolicyHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(accessPolicyHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update an access policy
         * @param {string} accessPolicyHref 
         * @param {AccessPolicy} accessPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(accessPolicyHref: string, accessPolicy: AccessPolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(accessPolicyHref, accessPolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessPoliciesApi - factory interface
 * @export
 */
export const AccessPoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessPoliciesApiFp(configuration)
    return {
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List access policys
         * @param {boolean} [customized] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [viewsetName] Filter results where viewset_name matches value
         * @param {string} [viewsetNameContains] Filter results where viewset_name contains value
         * @param {string} [viewsetNameIcontains] Filter results where viewset_name contains value
         * @param {Array<string>} [viewsetNameIn] Filter results where viewset_name is in a comma-separated list of values
         * @param {string} [viewsetNameStartswith] Filter results where viewset_name starts with value
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customized?: boolean, limit?: number, offset?: number, ordering?: string, viewsetName?: string, viewsetNameContains?: string, viewsetNameIcontains?: string, viewsetNameIn?: Array<string>, viewsetNameStartswith?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedAccessPolicyResponseList> {
            return localVarFp.list(customized, limit, offset, ordering, viewsetName, viewsetNameContains, viewsetNameIcontains, viewsetNameIn, viewsetNameStartswith, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update an access policy
         * @param {string} accessPolicyHref 
         * @param {PatchedAccessPolicy} patchedAccessPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(accessPolicyHref: string, patchedAccessPolicy: PatchedAccessPolicy, options?: any): AxiosPromise<AccessPolicyResponse> {
            return localVarFp.partialUpdate(accessPolicyHref, patchedAccessPolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect an access policy
         * @param {string} accessPolicyHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(accessPolicyHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<AccessPolicyResponse> {
            return localVarFp.read(accessPolicyHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update an access policy
         * @param {string} accessPolicyHref 
         * @param {AccessPolicy} accessPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(accessPolicyHref: string, accessPolicy: AccessPolicy, options?: any): AxiosPromise<AccessPolicyResponse> {
            return localVarFp.update(accessPolicyHref, accessPolicy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessPoliciesApi - object-oriented interface
 * @export
 * @class AccessPoliciesApi
 * @extends {BaseAPI}
 */
export class AccessPoliciesApi extends BaseAPI {
    /**
     * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary List access policys
     * @param {boolean} [customized] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [viewsetName] Filter results where viewset_name matches value
     * @param {string} [viewsetNameContains] Filter results where viewset_name contains value
     * @param {string} [viewsetNameIcontains] Filter results where viewset_name contains value
     * @param {Array<string>} [viewsetNameIn] Filter results where viewset_name is in a comma-separated list of values
     * @param {string} [viewsetNameStartswith] Filter results where viewset_name starts with value
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessPoliciesApi
     */
    public list(customized?: boolean, limit?: number, offset?: number, ordering?: string, viewsetName?: string, viewsetNameContains?: string, viewsetNameIcontains?: string, viewsetNameIn?: Array<string>, viewsetNameStartswith?: string, fields?: string, excludeFields?: string, options?: any) {
        return AccessPoliciesApiFp(this.configuration).list(customized, limit, offset, ordering, viewsetName, viewsetNameContains, viewsetNameIcontains, viewsetNameIn, viewsetNameStartswith, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Update an access policy
     * @param {string} accessPolicyHref 
     * @param {PatchedAccessPolicy} patchedAccessPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessPoliciesApi
     */
    public partialUpdate(accessPolicyHref: string, patchedAccessPolicy: PatchedAccessPolicy, options?: any) {
        return AccessPoliciesApiFp(this.configuration).partialUpdate(accessPolicyHref, patchedAccessPolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Inspect an access policy
     * @param {string} accessPolicyHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessPoliciesApi
     */
    public read(accessPolicyHref: string, fields?: string, excludeFields?: string, options?: any) {
        return AccessPoliciesApiFp(this.configuration).read(accessPolicyHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for AccessPolicy.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Update an access policy
     * @param {string} accessPolicyHref 
     * @param {AccessPolicy} accessPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessPoliciesApi
     */
    public update(accessPolicyHref: string, accessPolicy: AccessPolicy, options?: any) {
        return AccessPoliciesApiFp(this.configuration).update(accessPolicyHref, accessPolicy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ArtifactsApi - axios parameter creator
 * @export
 */
export const ArtifactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove Artifact only if it is not associated with any Content.
         * @summary Delete an artifact
         * @param {string} artifactHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (artifactHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactHref' is not null or undefined
            assertParamExists('_delete', 'artifactHref', artifactHref)
            const localVarPath = `{artifact_href}`
                .replace(`{${"artifact_href"}}`, String(artifactHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Create an artifact
         * @param {any} file The stored file.
         * @param {number} [size] The size of the file in bytes.
         * @param {string} [md5] The MD5 checksum of the file if available.
         * @param {string} [sha1] The SHA-1 checksum of the file if available.
         * @param {string} [sha224] The SHA-224 checksum of the file if available.
         * @param {string} [sha256] The SHA-256 checksum of the file if available.
         * @param {string} [sha384] The SHA-384 checksum of the file if available.
         * @param {string} [sha512] The SHA-512 checksum of the file if available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (file: any, size?: number, md5?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('create', 'file', file)
            const localVarPath = `/pulp/api/v3/artifacts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (size !== undefined) { 
                localVarFormParams.append('size', size as any);
            }
    
            if (md5 !== undefined) { 
                localVarFormParams.append('md5', md5 as any);
            }
    
            if (sha1 !== undefined) { 
                localVarFormParams.append('sha1', sha1 as any);
            }
    
            if (sha224 !== undefined) { 
                localVarFormParams.append('sha224', sha224 as any);
            }
    
            if (sha256 !== undefined) { 
                localVarFormParams.append('sha256', sha256 as any);
            }
    
            if (sha384 !== undefined) { 
                localVarFormParams.append('sha384', sha384 as any);
            }
    
            if (sha512 !== undefined) { 
                localVarFormParams.append('sha512', sha512 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List artifacts
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [md5] Filter results where md5 matches value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [sha1] Filter results where sha1 matches value
         * @param {string} [sha224] Filter results where sha224 matches value
         * @param {string} [sha256] Filter results where sha256 matches value
         * @param {string} [sha384] Filter results where sha384 matches value
         * @param {string} [sha512] Filter results where sha512 matches value
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, md5?: string, offset?: number, ordering?: string, repositoryVersion?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/artifacts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (md5 !== undefined) {
                localVarQueryParameter['md5'] = md5;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (sha1 !== undefined) {
                localVarQueryParameter['sha1'] = sha1;
            }

            if (sha224 !== undefined) {
                localVarQueryParameter['sha224'] = sha224;
            }

            if (sha256 !== undefined) {
                localVarQueryParameter['sha256'] = sha256;
            }

            if (sha384 !== undefined) {
                localVarQueryParameter['sha384'] = sha384;
            }

            if (sha512 !== undefined) {
                localVarQueryParameter['sha512'] = sha512;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect an artifact
         * @param {string} artifactHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (artifactHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactHref' is not null or undefined
            assertParamExists('read', 'artifactHref', artifactHref)
            const localVarPath = `{artifact_href}`
                .replace(`{${"artifact_href"}}`, String(artifactHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsApi - functional programming interface
 * @export
 */
export const ArtifactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Remove Artifact only if it is not associated with any Content.
         * @summary Delete an artifact
         * @param {string} artifactHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(artifactHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(artifactHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Create an artifact
         * @param {any} file The stored file.
         * @param {number} [size] The size of the file in bytes.
         * @param {string} [md5] The MD5 checksum of the file if available.
         * @param {string} [sha1] The SHA-1 checksum of the file if available.
         * @param {string} [sha224] The SHA-224 checksum of the file if available.
         * @param {string} [sha256] The SHA-256 checksum of the file if available.
         * @param {string} [sha384] The SHA-384 checksum of the file if available.
         * @param {string} [sha512] The SHA-512 checksum of the file if available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(file: any, size?: number, md5?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(file, size, md5, sha1, sha224, sha256, sha384, sha512, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List artifacts
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [md5] Filter results where md5 matches value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [sha1] Filter results where sha1 matches value
         * @param {string} [sha224] Filter results where sha224 matches value
         * @param {string} [sha256] Filter results where sha256 matches value
         * @param {string} [sha384] Filter results where sha384 matches value
         * @param {string} [sha512] Filter results where sha512 matches value
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, md5?: string, offset?: number, ordering?: string, repositoryVersion?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedArtifactResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, md5, offset, ordering, repositoryVersion, sha1, sha224, sha256, sha384, sha512, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect an artifact
         * @param {string} artifactHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(artifactHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(artifactHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtifactsApi - factory interface
 * @export
 */
export const ArtifactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactsApiFp(configuration)
    return {
        /**
         * Remove Artifact only if it is not associated with any Content.
         * @summary Delete an artifact
         * @param {string} artifactHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(artifactHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(artifactHref, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Create an artifact
         * @param {any} file The stored file.
         * @param {number} [size] The size of the file in bytes.
         * @param {string} [md5] The MD5 checksum of the file if available.
         * @param {string} [sha1] The SHA-1 checksum of the file if available.
         * @param {string} [sha224] The SHA-224 checksum of the file if available.
         * @param {string} [sha256] The SHA-256 checksum of the file if available.
         * @param {string} [sha384] The SHA-384 checksum of the file if available.
         * @param {string} [sha512] The SHA-512 checksum of the file if available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(file: any, size?: number, md5?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, options?: any): AxiosPromise<ArtifactResponse> {
            return localVarFp.create(file, size, md5, sha1, sha224, sha256, sha384, sha512, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List artifacts
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [md5] Filter results where md5 matches value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [sha1] Filter results where sha1 matches value
         * @param {string} [sha224] Filter results where sha224 matches value
         * @param {string} [sha256] Filter results where sha256 matches value
         * @param {string} [sha384] Filter results where sha384 matches value
         * @param {string} [sha512] Filter results where sha512 matches value
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, md5?: string, offset?: number, ordering?: string, repositoryVersion?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedArtifactResponseList> {
            return localVarFp.list(limit, md5, offset, ordering, repositoryVersion, sha1, sha224, sha256, sha384, sha512, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect an artifact
         * @param {string} artifactHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(artifactHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<ArtifactResponse> {
            return localVarFp.read(artifactHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactsApi - object-oriented interface
 * @export
 * @class ArtifactsApi
 * @extends {BaseAPI}
 */
export class ArtifactsApi extends BaseAPI {
    /**
     * Remove Artifact only if it is not associated with any Content.
     * @summary Delete an artifact
     * @param {string} artifactHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public _delete(artifactHref: string, options?: any) {
        return ArtifactsApiFp(this.configuration)._delete(artifactHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary Create an artifact
     * @param {any} file The stored file.
     * @param {number} [size] The size of the file in bytes.
     * @param {string} [md5] The MD5 checksum of the file if available.
     * @param {string} [sha1] The SHA-1 checksum of the file if available.
     * @param {string} [sha224] The SHA-224 checksum of the file if available.
     * @param {string} [sha256] The SHA-256 checksum of the file if available.
     * @param {string} [sha384] The SHA-384 checksum of the file if available.
     * @param {string} [sha512] The SHA-512 checksum of the file if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public create(file: any, size?: number, md5?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, options?: any) {
        return ArtifactsApiFp(this.configuration).create(file, size, md5, sha1, sha224, sha256, sha384, sha512, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary List artifacts
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [md5] Filter results where md5 matches value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [sha1] Filter results where sha1 matches value
     * @param {string} [sha224] Filter results where sha224 matches value
     * @param {string} [sha256] Filter results where sha256 matches value
     * @param {string} [sha384] Filter results where sha384 matches value
     * @param {string} [sha512] Filter results where sha512 matches value
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public list(limit?: number, md5?: string, offset?: number, ordering?: string, repositoryVersion?: string, sha1?: string, sha224?: string, sha256?: string, sha384?: string, sha512?: string, fields?: string, excludeFields?: string, options?: any) {
        return ArtifactsApiFp(this.configuration).list(limit, md5, offset, ordering, repositoryVersion, sha1, sha224, sha256, sha384, sha512, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary Inspect an artifact
     * @param {string} artifactHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public read(artifactHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ArtifactsApiFp(this.configuration).read(artifactHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentApi - axios parameter creator
 * @export
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint to list all content.
         * @summary List content
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint to list all content.
         * @summary List content
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMultipleArtifactContentResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentApiFp(configuration)
    return {
        /**
         * Endpoint to list all content.
         * @summary List content
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedMultipleArtifactContentResponseList> {
            return localVarFp.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
    /**
     * Endpoint to list all content.
     * @summary List content
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
     * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentApiFp(this.configuration).list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentguardsApi - axios parameter creator
 * @export
 */
export const ContentguardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint to list all contentguards.
         * @summary List content guards
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/contentguards/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentguardsApi - functional programming interface
 * @export
 */
export const ContentguardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentguardsApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint to list all contentguards.
         * @summary List content guards
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContentGuardResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentguardsApi - factory interface
 * @export
 */
export const ContentguardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentguardsApiFp(configuration)
    return {
        /**
         * Endpoint to list all contentguards.
         * @summary List content guards
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedContentGuardResponseList> {
            return localVarFp.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentguardsApi - object-oriented interface
 * @export
 * @class ContentguardsApi
 * @extends {BaseAPI}
 */
export class ContentguardsApi extends BaseAPI {
    /**
     * Endpoint to list all contentguards.
     * @summary List content guards
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentguardsApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentguardsApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentguardsRbacApi - axios parameter creator
 * @export
 */
export const ContentguardsRbacApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Delete a rbac content guard
         * @param {string} rBACContentGuardHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (rBACContentGuardHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rBACContentGuardHref' is not null or undefined
            assertParamExists('_delete', 'rBACContentGuardHref', rBACContentGuardHref)
            const localVarPath = `{r_b_a_c_content_guard_href}`
                .replace(`{${"r_b_a_c_content_guard_href"}}`, String(rBACContentGuardHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Give users and groups the `download` permission
         * @summary Add download permission
         * @param {string} rBACContentGuardHref 
         * @param {RBACContentGuardPermission} rBACContentGuardPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPermission: async (rBACContentGuardHref: string, rBACContentGuardPermission: RBACContentGuardPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rBACContentGuardHref' is not null or undefined
            assertParamExists('assignPermission', 'rBACContentGuardHref', rBACContentGuardHref)
            // verify required parameter 'rBACContentGuardPermission' is not null or undefined
            assertParamExists('assignPermission', 'rBACContentGuardPermission', rBACContentGuardPermission)
            const localVarPath = `{r_b_a_c_content_guard_href}assign_permission/`
                .replace(`{${"r_b_a_c_content_guard_href"}}`, String(rBACContentGuardHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rBACContentGuardPermission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Create a rbac content guard
         * @param {RBACContentGuard} rBACContentGuard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (rBACContentGuard: RBACContentGuard, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rBACContentGuard' is not null or undefined
            assertParamExists('create', 'rBACContentGuard', rBACContentGuard)
            const localVarPath = `/pulp/api/v3/contentguards/core/rbac/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rBACContentGuard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary List rbac content guards
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/contentguards/core/rbac/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Update a rbac content guard
         * @param {string} rBACContentGuardHref 
         * @param {PatchedRBACContentGuard} patchedRBACContentGuard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (rBACContentGuardHref: string, patchedRBACContentGuard: PatchedRBACContentGuard, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rBACContentGuardHref' is not null or undefined
            assertParamExists('partialUpdate', 'rBACContentGuardHref', rBACContentGuardHref)
            // verify required parameter 'patchedRBACContentGuard' is not null or undefined
            assertParamExists('partialUpdate', 'patchedRBACContentGuard', patchedRBACContentGuard)
            const localVarPath = `{r_b_a_c_content_guard_href}`
                .replace(`{${"r_b_a_c_content_guard_href"}}`, String(rBACContentGuardHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRBACContentGuard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Inspect a rbac content guard
         * @param {string} rBACContentGuardHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rBACContentGuardHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rBACContentGuardHref' is not null or undefined
            assertParamExists('read', 'rBACContentGuardHref', rBACContentGuardHref)
            const localVarPath = `{r_b_a_c_content_guard_href}`
                .replace(`{${"r_b_a_c_content_guard_href"}}`, String(rBACContentGuardHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove `download` permission from users and groups
         * @summary Remove download permission
         * @param {string} rBACContentGuardHref 
         * @param {RBACContentGuardPermission} rBACContentGuardPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermission: async (rBACContentGuardHref: string, rBACContentGuardPermission: RBACContentGuardPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rBACContentGuardHref' is not null or undefined
            assertParamExists('removePermission', 'rBACContentGuardHref', rBACContentGuardHref)
            // verify required parameter 'rBACContentGuardPermission' is not null or undefined
            assertParamExists('removePermission', 'rBACContentGuardPermission', rBACContentGuardPermission)
            const localVarPath = `{r_b_a_c_content_guard_href}remove_permission/`
                .replace(`{${"r_b_a_c_content_guard_href"}}`, String(rBACContentGuardHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rBACContentGuardPermission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Update a rbac content guard
         * @param {string} rBACContentGuardHref 
         * @param {RBACContentGuard} rBACContentGuard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (rBACContentGuardHref: string, rBACContentGuard: RBACContentGuard, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rBACContentGuardHref' is not null or undefined
            assertParamExists('update', 'rBACContentGuardHref', rBACContentGuardHref)
            // verify required parameter 'rBACContentGuard' is not null or undefined
            assertParamExists('update', 'rBACContentGuard', rBACContentGuard)
            const localVarPath = `{r_b_a_c_content_guard_href}`
                .replace(`{${"r_b_a_c_content_guard_href"}}`, String(rBACContentGuardHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rBACContentGuard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentguardsRbacApi - functional programming interface
 * @export
 */
export const ContentguardsRbacApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentguardsRbacApiAxiosParamCreator(configuration)
    return {
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Delete a rbac content guard
         * @param {string} rBACContentGuardHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(rBACContentGuardHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(rBACContentGuardHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Give users and groups the `download` permission
         * @summary Add download permission
         * @param {string} rBACContentGuardHref 
         * @param {RBACContentGuardPermission} rBACContentGuardPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignPermission(rBACContentGuardHref: string, rBACContentGuardPermission: RBACContentGuardPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RBACContentGuardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignPermission(rBACContentGuardHref, rBACContentGuardPermission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Create a rbac content guard
         * @param {RBACContentGuard} rBACContentGuard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(rBACContentGuard: RBACContentGuard, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RBACContentGuardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(rBACContentGuard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary List rbac content guards
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRBACContentGuardResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Update a rbac content guard
         * @param {string} rBACContentGuardHref 
         * @param {PatchedRBACContentGuard} patchedRBACContentGuard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(rBACContentGuardHref: string, patchedRBACContentGuard: PatchedRBACContentGuard, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RBACContentGuardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(rBACContentGuardHref, patchedRBACContentGuard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Inspect a rbac content guard
         * @param {string} rBACContentGuardHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rBACContentGuardHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RBACContentGuardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rBACContentGuardHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove `download` permission from users and groups
         * @summary Remove download permission
         * @param {string} rBACContentGuardHref 
         * @param {RBACContentGuardPermission} rBACContentGuardPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePermission(rBACContentGuardHref: string, rBACContentGuardPermission: RBACContentGuardPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RBACContentGuardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePermission(rBACContentGuardHref, rBACContentGuardPermission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Update a rbac content guard
         * @param {string} rBACContentGuardHref 
         * @param {RBACContentGuard} rBACContentGuard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(rBACContentGuardHref: string, rBACContentGuard: RBACContentGuard, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RBACContentGuardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(rBACContentGuardHref, rBACContentGuard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentguardsRbacApi - factory interface
 * @export
 */
export const ContentguardsRbacApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentguardsRbacApiFp(configuration)
    return {
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Delete a rbac content guard
         * @param {string} rBACContentGuardHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(rBACContentGuardHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(rBACContentGuardHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Give users and groups the `download` permission
         * @summary Add download permission
         * @param {string} rBACContentGuardHref 
         * @param {RBACContentGuardPermission} rBACContentGuardPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPermission(rBACContentGuardHref: string, rBACContentGuardPermission: RBACContentGuardPermission, options?: any): AxiosPromise<RBACContentGuardResponse> {
            return localVarFp.assignPermission(rBACContentGuardHref, rBACContentGuardPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Create a rbac content guard
         * @param {RBACContentGuard} rBACContentGuard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(rBACContentGuard: RBACContentGuard, options?: any): AxiosPromise<RBACContentGuardResponse> {
            return localVarFp.create(rBACContentGuard, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary List rbac content guards
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedRBACContentGuardResponseList> {
            return localVarFp.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Update a rbac content guard
         * @param {string} rBACContentGuardHref 
         * @param {PatchedRBACContentGuard} patchedRBACContentGuard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(rBACContentGuardHref: string, patchedRBACContentGuard: PatchedRBACContentGuard, options?: any): AxiosPromise<RBACContentGuardResponse> {
            return localVarFp.partialUpdate(rBACContentGuardHref, patchedRBACContentGuard, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Inspect a rbac content guard
         * @param {string} rBACContentGuardHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rBACContentGuardHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RBACContentGuardResponse> {
            return localVarFp.read(rBACContentGuardHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove `download` permission from users and groups
         * @summary Remove download permission
         * @param {string} rBACContentGuardHref 
         * @param {RBACContentGuardPermission} rBACContentGuardPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermission(rBACContentGuardHref: string, rBACContentGuardPermission: RBACContentGuardPermission, options?: any): AxiosPromise<RBACContentGuardResponse> {
            return localVarFp.removePermission(rBACContentGuardHref, rBACContentGuardPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
         * @summary Update a rbac content guard
         * @param {string} rBACContentGuardHref 
         * @param {RBACContentGuard} rBACContentGuard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(rBACContentGuardHref: string, rBACContentGuard: RBACContentGuard, options?: any): AxiosPromise<RBACContentGuardResponse> {
            return localVarFp.update(rBACContentGuardHref, rBACContentGuard, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentguardsRbacApi - object-oriented interface
 * @export
 * @class ContentguardsRbacApi
 * @extends {BaseAPI}
 */
export class ContentguardsRbacApi extends BaseAPI {
    /**
     * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
     * @summary Delete a rbac content guard
     * @param {string} rBACContentGuardHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentguardsRbacApi
     */
    public _delete(rBACContentGuardHref: string, options?: any) {
        return ContentguardsRbacApiFp(this.configuration)._delete(rBACContentGuardHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Give users and groups the `download` permission
     * @summary Add download permission
     * @param {string} rBACContentGuardHref 
     * @param {RBACContentGuardPermission} rBACContentGuardPermission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentguardsRbacApi
     */
    public assignPermission(rBACContentGuardHref: string, rBACContentGuardPermission: RBACContentGuardPermission, options?: any) {
        return ContentguardsRbacApiFp(this.configuration).assignPermission(rBACContentGuardHref, rBACContentGuardPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
     * @summary Create a rbac content guard
     * @param {RBACContentGuard} rBACContentGuard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentguardsRbacApi
     */
    public create(rBACContentGuard: RBACContentGuard, options?: any) {
        return ContentguardsRbacApiFp(this.configuration).create(rBACContentGuard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
     * @summary List rbac content guards
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentguardsRbacApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentguardsRbacApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
     * @summary Update a rbac content guard
     * @param {string} rBACContentGuardHref 
     * @param {PatchedRBACContentGuard} patchedRBACContentGuard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentguardsRbacApi
     */
    public partialUpdate(rBACContentGuardHref: string, patchedRBACContentGuard: PatchedRBACContentGuard, options?: any) {
        return ContentguardsRbacApiFp(this.configuration).partialUpdate(rBACContentGuardHref, patchedRBACContentGuard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
     * @summary Inspect a rbac content guard
     * @param {string} rBACContentGuardHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentguardsRbacApi
     */
    public read(rBACContentGuardHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentguardsRbacApiFp(this.configuration).read(rBACContentGuardHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove `download` permission from users and groups
     * @summary Remove download permission
     * @param {string} rBACContentGuardHref 
     * @param {RBACContentGuardPermission} rBACContentGuardPermission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentguardsRbacApi
     */
    public removePermission(rBACContentGuardHref: string, rBACContentGuardPermission: RBACContentGuardPermission, options?: any) {
        return ContentguardsRbacApiFp(this.configuration).removePermission(rBACContentGuardHref, rBACContentGuardPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Viewset for creating contentguards that use RBAC to protect content. Has add and remove actions for managing permission for users and groups to download content protected by this guard.
     * @summary Update a rbac content guard
     * @param {string} rBACContentGuardHref 
     * @param {RBACContentGuard} rBACContentGuard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentguardsRbacApi
     */
    public update(rBACContentGuardHref: string, rBACContentGuard: RBACContentGuard, options?: any) {
        return ContentguardsRbacApiFp(this.configuration).update(rBACContentGuardHref, rBACContentGuard, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExportersFilesystemApi - axios parameter creator
 * @export
 */
export const ExportersFilesystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a filesystem exporter
         * @param {string} filesystemExporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (filesystemExporterHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filesystemExporterHref' is not null or undefined
            assertParamExists('_delete', 'filesystemExporterHref', filesystemExporterHref)
            const localVarPath = `{filesystem_exporter_href}`
                .replace(`{${"filesystem_exporter_href"}}`, String(filesystemExporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for managing FilesystemExporters. FilesystemExporters are provided as a tech preview.
         * @summary Create a filesystem exporter
         * @param {FilesystemExporter} filesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (filesystemExporter: FilesystemExporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filesystemExporter' is not null or undefined
            assertParamExists('create', 'filesystemExporter', filesystemExporter)
            const localVarPath = `/pulp/api/v3/exporters/core/filesystem/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filesystemExporter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for managing FilesystemExporters. FilesystemExporters are provided as a tech preview.
         * @summary List filesystem exporters
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/exporters/core/filesystem/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a filesystem exporter
         * @param {string} filesystemExporterHref 
         * @param {PatchedFilesystemExporter} patchedFilesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (filesystemExporterHref: string, patchedFilesystemExporter: PatchedFilesystemExporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filesystemExporterHref' is not null or undefined
            assertParamExists('partialUpdate', 'filesystemExporterHref', filesystemExporterHref)
            // verify required parameter 'patchedFilesystemExporter' is not null or undefined
            assertParamExists('partialUpdate', 'patchedFilesystemExporter', patchedFilesystemExporter)
            const localVarPath = `{filesystem_exporter_href}`
                .replace(`{${"filesystem_exporter_href"}}`, String(filesystemExporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFilesystemExporter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for managing FilesystemExporters. FilesystemExporters are provided as a tech preview.
         * @summary Inspect a filesystem exporter
         * @param {string} filesystemExporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (filesystemExporterHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filesystemExporterHref' is not null or undefined
            assertParamExists('read', 'filesystemExporterHref', filesystemExporterHref)
            const localVarPath = `{filesystem_exporter_href}`
                .replace(`{${"filesystem_exporter_href"}}`, String(filesystemExporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a filesystem exporter
         * @param {string} filesystemExporterHref 
         * @param {FilesystemExporter} filesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (filesystemExporterHref: string, filesystemExporter: FilesystemExporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filesystemExporterHref' is not null or undefined
            assertParamExists('update', 'filesystemExporterHref', filesystemExporterHref)
            // verify required parameter 'filesystemExporter' is not null or undefined
            assertParamExists('update', 'filesystemExporter', filesystemExporter)
            const localVarPath = `{filesystem_exporter_href}`
                .replace(`{${"filesystem_exporter_href"}}`, String(filesystemExporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filesystemExporter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportersFilesystemApi - functional programming interface
 * @export
 */
export const ExportersFilesystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportersFilesystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a filesystem exporter
         * @param {string} filesystemExporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(filesystemExporterHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(filesystemExporterHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for managing FilesystemExporters. FilesystemExporters are provided as a tech preview.
         * @summary Create a filesystem exporter
         * @param {FilesystemExporter} filesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(filesystemExporter: FilesystemExporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesystemExporterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(filesystemExporter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for managing FilesystemExporters. FilesystemExporters are provided as a tech preview.
         * @summary List filesystem exporters
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFilesystemExporterResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a filesystem exporter
         * @param {string} filesystemExporterHref 
         * @param {PatchedFilesystemExporter} patchedFilesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(filesystemExporterHref: string, patchedFilesystemExporter: PatchedFilesystemExporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(filesystemExporterHref, patchedFilesystemExporter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for managing FilesystemExporters. FilesystemExporters are provided as a tech preview.
         * @summary Inspect a filesystem exporter
         * @param {string} filesystemExporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(filesystemExporterHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesystemExporterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(filesystemExporterHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a filesystem exporter
         * @param {string} filesystemExporterHref 
         * @param {FilesystemExporter} filesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(filesystemExporterHref: string, filesystemExporter: FilesystemExporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(filesystemExporterHref, filesystemExporter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExportersFilesystemApi - factory interface
 * @export
 */
export const ExportersFilesystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportersFilesystemApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a filesystem exporter
         * @param {string} filesystemExporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(filesystemExporterHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp._delete(filesystemExporterHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for managing FilesystemExporters. FilesystemExporters are provided as a tech preview.
         * @summary Create a filesystem exporter
         * @param {FilesystemExporter} filesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(filesystemExporter: FilesystemExporter, options?: any): AxiosPromise<FilesystemExporterResponse> {
            return localVarFp.create(filesystemExporter, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for managing FilesystemExporters. FilesystemExporters are provided as a tech preview.
         * @summary List filesystem exporters
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedFilesystemExporterResponseList> {
            return localVarFp.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a filesystem exporter
         * @param {string} filesystemExporterHref 
         * @param {PatchedFilesystemExporter} patchedFilesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(filesystemExporterHref: string, patchedFilesystemExporter: PatchedFilesystemExporter, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.partialUpdate(filesystemExporterHref, patchedFilesystemExporter, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for managing FilesystemExporters. FilesystemExporters are provided as a tech preview.
         * @summary Inspect a filesystem exporter
         * @param {string} filesystemExporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(filesystemExporterHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FilesystemExporterResponse> {
            return localVarFp.read(filesystemExporterHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a filesystem exporter
         * @param {string} filesystemExporterHref 
         * @param {FilesystemExporter} filesystemExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(filesystemExporterHref: string, filesystemExporter: FilesystemExporter, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.update(filesystemExporterHref, filesystemExporter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportersFilesystemApi - object-oriented interface
 * @export
 * @class ExportersFilesystemApi
 * @extends {BaseAPI}
 */
export class ExportersFilesystemApi extends BaseAPI {
    /**
     * Trigger an asynchronous delete task
     * @summary Delete a filesystem exporter
     * @param {string} filesystemExporterHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemApi
     */
    public _delete(filesystemExporterHref: string, options?: any) {
        return ExportersFilesystemApiFp(this.configuration)._delete(filesystemExporterHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for managing FilesystemExporters. FilesystemExporters are provided as a tech preview.
     * @summary Create a filesystem exporter
     * @param {FilesystemExporter} filesystemExporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemApi
     */
    public create(filesystemExporter: FilesystemExporter, options?: any) {
        return ExportersFilesystemApiFp(this.configuration).create(filesystemExporter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for managing FilesystemExporters. FilesystemExporters are provided as a tech preview.
     * @summary List filesystem exporters
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersFilesystemApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous partial update task
     * @summary Update a filesystem exporter
     * @param {string} filesystemExporterHref 
     * @param {PatchedFilesystemExporter} patchedFilesystemExporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemApi
     */
    public partialUpdate(filesystemExporterHref: string, patchedFilesystemExporter: PatchedFilesystemExporter, options?: any) {
        return ExportersFilesystemApiFp(this.configuration).partialUpdate(filesystemExporterHref, patchedFilesystemExporter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for managing FilesystemExporters. FilesystemExporters are provided as a tech preview.
     * @summary Inspect a filesystem exporter
     * @param {string} filesystemExporterHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemApi
     */
    public read(filesystemExporterHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersFilesystemApiFp(this.configuration).read(filesystemExporterHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous update task
     * @summary Update a filesystem exporter
     * @param {string} filesystemExporterHref 
     * @param {FilesystemExporter} filesystemExporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemApi
     */
    public update(filesystemExporterHref: string, filesystemExporter: FilesystemExporter, options?: any) {
        return ExportersFilesystemApiFp(this.configuration).update(filesystemExporterHref, filesystemExporter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExportersFilesystemExportsApi - axios parameter creator
 * @export
 */
export const ExportersFilesystemExportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint for managing FilesystemExports. This endpoint is provided as a tech preview.
         * @summary Delete a filesystem export
         * @param {string} filesystemFilesystemExportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (filesystemFilesystemExportHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filesystemFilesystemExportHref' is not null or undefined
            assertParamExists('_delete', 'filesystemFilesystemExportHref', filesystemFilesystemExportHref)
            const localVarPath = `{filesystem_filesystem_export_href}`
                .replace(`{${"filesystem_filesystem_export_href"}}`, String(filesystemFilesystemExportHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to export files to the filesystem
         * @summary Create a filesystem export
         * @param {string} filesystemExporterHref 
         * @param {FilesystemExport} filesystemExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (filesystemExporterHref: string, filesystemExport: FilesystemExport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filesystemExporterHref' is not null or undefined
            assertParamExists('create', 'filesystemExporterHref', filesystemExporterHref)
            // verify required parameter 'filesystemExport' is not null or undefined
            assertParamExists('create', 'filesystemExport', filesystemExport)
            const localVarPath = `{filesystem_exporter_href}exports/`
                .replace(`{${"filesystem_exporter_href"}}`, String(filesystemExporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filesystemExport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for managing FilesystemExports. This endpoint is provided as a tech preview.
         * @summary List filesystem exports
         * @param {string} filesystemExporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (filesystemExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filesystemExporterHref' is not null or undefined
            assertParamExists('list', 'filesystemExporterHref', filesystemExporterHref)
            const localVarPath = `{filesystem_exporter_href}exports/`
                .replace(`{${"filesystem_exporter_href"}}`, String(filesystemExporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for managing FilesystemExports. This endpoint is provided as a tech preview.
         * @summary Inspect a filesystem export
         * @param {string} filesystemFilesystemExportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (filesystemFilesystemExportHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filesystemFilesystemExportHref' is not null or undefined
            assertParamExists('read', 'filesystemFilesystemExportHref', filesystemFilesystemExportHref)
            const localVarPath = `{filesystem_filesystem_export_href}`
                .replace(`{${"filesystem_filesystem_export_href"}}`, String(filesystemFilesystemExportHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportersFilesystemExportsApi - functional programming interface
 * @export
 */
export const ExportersFilesystemExportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportersFilesystemExportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint for managing FilesystemExports. This endpoint is provided as a tech preview.
         * @summary Delete a filesystem export
         * @param {string} filesystemFilesystemExportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(filesystemFilesystemExportHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(filesystemFilesystemExportHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous task to export files to the filesystem
         * @summary Create a filesystem export
         * @param {string} filesystemExporterHref 
         * @param {FilesystemExport} filesystemExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(filesystemExporterHref: string, filesystemExport: FilesystemExport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(filesystemExporterHref, filesystemExport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for managing FilesystemExports. This endpoint is provided as a tech preview.
         * @summary List filesystem exports
         * @param {string} filesystemExporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(filesystemExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFilesystemExportResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(filesystemExporterHref, limit, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for managing FilesystemExports. This endpoint is provided as a tech preview.
         * @summary Inspect a filesystem export
         * @param {string} filesystemFilesystemExportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(filesystemFilesystemExportHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesystemExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(filesystemFilesystemExportHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExportersFilesystemExportsApi - factory interface
 * @export
 */
export const ExportersFilesystemExportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportersFilesystemExportsApiFp(configuration)
    return {
        /**
         * Endpoint for managing FilesystemExports. This endpoint is provided as a tech preview.
         * @summary Delete a filesystem export
         * @param {string} filesystemFilesystemExportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(filesystemFilesystemExportHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(filesystemFilesystemExportHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to export files to the filesystem
         * @summary Create a filesystem export
         * @param {string} filesystemExporterHref 
         * @param {FilesystemExport} filesystemExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(filesystemExporterHref: string, filesystemExport: FilesystemExport, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.create(filesystemExporterHref, filesystemExport, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for managing FilesystemExports. This endpoint is provided as a tech preview.
         * @summary List filesystem exports
         * @param {string} filesystemExporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(filesystemExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedFilesystemExportResponseList> {
            return localVarFp.list(filesystemExporterHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for managing FilesystemExports. This endpoint is provided as a tech preview.
         * @summary Inspect a filesystem export
         * @param {string} filesystemFilesystemExportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(filesystemFilesystemExportHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FilesystemExportResponse> {
            return localVarFp.read(filesystemFilesystemExportHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportersFilesystemExportsApi - object-oriented interface
 * @export
 * @class ExportersFilesystemExportsApi
 * @extends {BaseAPI}
 */
export class ExportersFilesystemExportsApi extends BaseAPI {
    /**
     * Endpoint for managing FilesystemExports. This endpoint is provided as a tech preview.
     * @summary Delete a filesystem export
     * @param {string} filesystemFilesystemExportHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemExportsApi
     */
    public _delete(filesystemFilesystemExportHref: string, options?: any) {
        return ExportersFilesystemExportsApiFp(this.configuration)._delete(filesystemFilesystemExportHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to export files to the filesystem
     * @summary Create a filesystem export
     * @param {string} filesystemExporterHref 
     * @param {FilesystemExport} filesystemExport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemExportsApi
     */
    public create(filesystemExporterHref: string, filesystemExport: FilesystemExport, options?: any) {
        return ExportersFilesystemExportsApiFp(this.configuration).create(filesystemExporterHref, filesystemExport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for managing FilesystemExports. This endpoint is provided as a tech preview.
     * @summary List filesystem exports
     * @param {string} filesystemExporterHref 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemExportsApi
     */
    public list(filesystemExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersFilesystemExportsApiFp(this.configuration).list(filesystemExporterHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for managing FilesystemExports. This endpoint is provided as a tech preview.
     * @summary Inspect a filesystem export
     * @param {string} filesystemFilesystemExportHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersFilesystemExportsApi
     */
    public read(filesystemFilesystemExportHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersFilesystemExportsApiFp(this.configuration).read(filesystemFilesystemExportHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExportersPulpApi - axios parameter creator
 * @export
 */
export const ExportersPulpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (pulpExporterHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporterHref' is not null or undefined
            assertParamExists('_delete', 'pulpExporterHref', pulpExporterHref)
            const localVarPath = `{pulp_exporter_href}`
                .replace(`{${"pulp_exporter_href"}}`, String(pulpExporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Create a pulp exporter
         * @param {PulpExporter} pulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (pulpExporter: PulpExporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporter' is not null or undefined
            assertParamExists('create', 'pulpExporter', pulpExporter)
            const localVarPath = `/pulp/api/v3/exporters/core/pulp/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pulpExporter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary List pulp exporters
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/exporters/core/pulp/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {PatchedPulpExporter} patchedPulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (pulpExporterHref: string, patchedPulpExporter: PatchedPulpExporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporterHref' is not null or undefined
            assertParamExists('partialUpdate', 'pulpExporterHref', pulpExporterHref)
            // verify required parameter 'patchedPulpExporter' is not null or undefined
            assertParamExists('partialUpdate', 'patchedPulpExporter', patchedPulpExporter)
            const localVarPath = `{pulp_exporter_href}`
                .replace(`{${"pulp_exporter_href"}}`, String(pulpExporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPulpExporter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Inspect a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (pulpExporterHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporterHref' is not null or undefined
            assertParamExists('read', 'pulpExporterHref', pulpExporterHref)
            const localVarPath = `{pulp_exporter_href}`
                .replace(`{${"pulp_exporter_href"}}`, String(pulpExporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {PulpExporter} pulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (pulpExporterHref: string, pulpExporter: PulpExporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporterHref' is not null or undefined
            assertParamExists('update', 'pulpExporterHref', pulpExporterHref)
            // verify required parameter 'pulpExporter' is not null or undefined
            assertParamExists('update', 'pulpExporter', pulpExporter)
            const localVarPath = `{pulp_exporter_href}`
                .replace(`{${"pulp_exporter_href"}}`, String(pulpExporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pulpExporter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportersPulpApi - functional programming interface
 * @export
 */
export const ExportersPulpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportersPulpApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(pulpExporterHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(pulpExporterHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Create a pulp exporter
         * @param {PulpExporter} pulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(pulpExporter: PulpExporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpExporterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(pulpExporter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary List pulp exporters
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPulpExporterResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {PatchedPulpExporter} patchedPulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(pulpExporterHref: string, patchedPulpExporter: PatchedPulpExporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(pulpExporterHref, patchedPulpExporter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Inspect a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(pulpExporterHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpExporterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(pulpExporterHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {PulpExporter} pulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(pulpExporterHref: string, pulpExporter: PulpExporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(pulpExporterHref, pulpExporter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExportersPulpApi - factory interface
 * @export
 */
export const ExportersPulpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportersPulpApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(pulpExporterHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp._delete(pulpExporterHref, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Create a pulp exporter
         * @param {PulpExporter} pulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(pulpExporter: PulpExporter, options?: any): AxiosPromise<PulpExporterResponse> {
            return localVarFp.create(pulpExporter, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary List pulp exporters
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedPulpExporterResponseList> {
            return localVarFp.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {PatchedPulpExporter} patchedPulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(pulpExporterHref: string, patchedPulpExporter: PatchedPulpExporter, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.partialUpdate(pulpExporterHref, patchedPulpExporter, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for viewing PulpExporters.
         * @summary Inspect a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(pulpExporterHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PulpExporterResponse> {
            return localVarFp.read(pulpExporterHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a pulp exporter
         * @param {string} pulpExporterHref 
         * @param {PulpExporter} pulpExporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(pulpExporterHref: string, pulpExporter: PulpExporter, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.update(pulpExporterHref, pulpExporter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportersPulpApi - object-oriented interface
 * @export
 * @class ExportersPulpApi
 * @extends {BaseAPI}
 */
export class ExportersPulpApi extends BaseAPI {
    /**
     * Trigger an asynchronous delete task
     * @summary Delete a pulp exporter
     * @param {string} pulpExporterHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpApi
     */
    public _delete(pulpExporterHref: string, options?: any) {
        return ExportersPulpApiFp(this.configuration)._delete(pulpExporterHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for viewing PulpExporters.
     * @summary Create a pulp exporter
     * @param {PulpExporter} pulpExporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpApi
     */
    public create(pulpExporter: PulpExporter, options?: any) {
        return ExportersPulpApiFp(this.configuration).create(pulpExporter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for viewing PulpExporters.
     * @summary List pulp exporters
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersPulpApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous partial update task
     * @summary Update a pulp exporter
     * @param {string} pulpExporterHref 
     * @param {PatchedPulpExporter} patchedPulpExporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpApi
     */
    public partialUpdate(pulpExporterHref: string, patchedPulpExporter: PatchedPulpExporter, options?: any) {
        return ExportersPulpApiFp(this.configuration).partialUpdate(pulpExporterHref, patchedPulpExporter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for viewing PulpExporters.
     * @summary Inspect a pulp exporter
     * @param {string} pulpExporterHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpApi
     */
    public read(pulpExporterHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersPulpApiFp(this.configuration).read(pulpExporterHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous update task
     * @summary Update a pulp exporter
     * @param {string} pulpExporterHref 
     * @param {PulpExporter} pulpExporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpApi
     */
    public update(pulpExporterHref: string, pulpExporter: PulpExporter, options?: any) {
        return ExportersPulpApiFp(this.configuration).update(pulpExporterHref, pulpExporter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExportersPulpExportsApi - axios parameter creator
 * @export
 */
export const ExportersPulpExportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary Delete a pulp export
         * @param {string} pulpPulpExportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (pulpPulpExportHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpPulpExportHref' is not null or undefined
            assertParamExists('_delete', 'pulpPulpExportHref', pulpPulpExportHref)
            const localVarPath = `{pulp_pulp_export_href}`
                .replace(`{${"pulp_pulp_export_href"}}`, String(pulpPulpExportHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to export a set of repositories
         * @summary Create a pulp export
         * @param {string} pulpExporterHref 
         * @param {PulpExport} pulpExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (pulpExporterHref: string, pulpExport: PulpExport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporterHref' is not null or undefined
            assertParamExists('create', 'pulpExporterHref', pulpExporterHref)
            // verify required parameter 'pulpExport' is not null or undefined
            assertParamExists('create', 'pulpExport', pulpExport)
            const localVarPath = `{pulp_exporter_href}exports/`
                .replace(`{${"pulp_exporter_href"}}`, String(pulpExporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pulpExport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary List pulp exports
         * @param {string} pulpExporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (pulpExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpExporterHref' is not null or undefined
            assertParamExists('list', 'pulpExporterHref', pulpExporterHref)
            const localVarPath = `{pulp_exporter_href}exports/`
                .replace(`{${"pulp_exporter_href"}}`, String(pulpExporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary Inspect a pulp export
         * @param {string} pulpPulpExportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (pulpPulpExportHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpPulpExportHref' is not null or undefined
            assertParamExists('read', 'pulpPulpExportHref', pulpPulpExportHref)
            const localVarPath = `{pulp_pulp_export_href}`
                .replace(`{${"pulp_pulp_export_href"}}`, String(pulpPulpExportHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportersPulpExportsApi - functional programming interface
 * @export
 */
export const ExportersPulpExportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportersPulpExportsApiAxiosParamCreator(configuration)
    return {
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary Delete a pulp export
         * @param {string} pulpPulpExportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(pulpPulpExportHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(pulpPulpExportHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous task to export a set of repositories
         * @summary Create a pulp export
         * @param {string} pulpExporterHref 
         * @param {PulpExport} pulpExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(pulpExporterHref: string, pulpExport: PulpExport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(pulpExporterHref, pulpExport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary List pulp exports
         * @param {string} pulpExporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(pulpExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPulpExportResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(pulpExporterHref, limit, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary Inspect a pulp export
         * @param {string} pulpPulpExportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(pulpPulpExportHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(pulpPulpExportHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExportersPulpExportsApi - factory interface
 * @export
 */
export const ExportersPulpExportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportersPulpExportsApiFp(configuration)
    return {
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary Delete a pulp export
         * @param {string} pulpPulpExportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(pulpPulpExportHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(pulpPulpExportHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to export a set of repositories
         * @summary Create a pulp export
         * @param {string} pulpExporterHref 
         * @param {PulpExport} pulpExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(pulpExporterHref: string, pulpExport: PulpExport, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.create(pulpExporterHref, pulpExport, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary List pulp exports
         * @param {string} pulpExporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(pulpExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedPulpExportResponseList> {
            return localVarFp.list(pulpExporterHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for viewing exports from a PulpExporter.
         * @summary Inspect a pulp export
         * @param {string} pulpPulpExportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(pulpPulpExportHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PulpExportResponse> {
            return localVarFp.read(pulpPulpExportHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportersPulpExportsApi - object-oriented interface
 * @export
 * @class ExportersPulpExportsApi
 * @extends {BaseAPI}
 */
export class ExportersPulpExportsApi extends BaseAPI {
    /**
     * ViewSet for viewing exports from a PulpExporter.
     * @summary Delete a pulp export
     * @param {string} pulpPulpExportHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpExportsApi
     */
    public _delete(pulpPulpExportHref: string, options?: any) {
        return ExportersPulpExportsApiFp(this.configuration)._delete(pulpPulpExportHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to export a set of repositories
     * @summary Create a pulp export
     * @param {string} pulpExporterHref 
     * @param {PulpExport} pulpExport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpExportsApi
     */
    public create(pulpExporterHref: string, pulpExport: PulpExport, options?: any) {
        return ExportersPulpExportsApiFp(this.configuration).create(pulpExporterHref, pulpExport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for viewing exports from a PulpExporter.
     * @summary List pulp exports
     * @param {string} pulpExporterHref 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpExportsApi
     */
    public list(pulpExporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersPulpExportsApiFp(this.configuration).list(pulpExporterHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for viewing exports from a PulpExporter.
     * @summary Inspect a pulp export
     * @param {string} pulpPulpExportHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportersPulpExportsApi
     */
    public read(pulpPulpExportHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ExportersPulpExportsApiFp(this.configuration).read(pulpPulpExportHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Delete a group
         * @param {string} authGroupHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (authGroupHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            assertParamExists('_delete', 'authGroupHref', authGroupHref)
            const localVarPath = `{auth_group_href}`
                .replace(`{${"auth_group_href"}}`, String(authGroupHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Create a group
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (group: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('create', 'group', group)
            const localVarPath = `/pulp/api/v3/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List groups
         * @param {number} [id] Filter results where id matches value
         * @param {Array<number>} [idIn] Filter results where id is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] Filter results where name matches value
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {string} [nameIexact] Filter results where name matches value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (id?: number, idIn?: Array<number>, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIexact?: string, nameIn?: Array<string>, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (idIn) {
                localVarQueryParameter['id__in'] = idIn.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIexact !== undefined) {
                localVarQueryParameter['name__iexact'] = nameIexact;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update a group
         * @param {string} authGroupHref 
         * @param {PatchedGroup} patchedGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (authGroupHref: string, patchedGroup: PatchedGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            assertParamExists('partialUpdate', 'authGroupHref', authGroupHref)
            // verify required parameter 'patchedGroup' is not null or undefined
            assertParamExists('partialUpdate', 'patchedGroup', patchedGroup)
            const localVarPath = `{auth_group_href}`
                .replace(`{${"auth_group_href"}}`, String(authGroupHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect a group
         * @param {string} authGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (authGroupHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            assertParamExists('read', 'authGroupHref', authGroupHref)
            const localVarPath = `{auth_group_href}`
                .replace(`{${"auth_group_href"}}`, String(authGroupHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update a group
         * @param {string} authGroupHref 
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (authGroupHref: string, group: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            assertParamExists('update', 'authGroupHref', authGroupHref)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('update', 'group', group)
            const localVarPath = `{auth_group_href}`
                .replace(`{${"auth_group_href"}}`, String(authGroupHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Delete a group
         * @param {string} authGroupHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(authGroupHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(authGroupHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Create a group
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(group: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List groups
         * @param {number} [id] Filter results where id matches value
         * @param {Array<number>} [idIn] Filter results where id is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] Filter results where name matches value
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {string} [nameIexact] Filter results where name matches value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(id?: number, idIn?: Array<number>, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIexact?: string, nameIn?: Array<string>, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGroupResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(id, idIn, limit, name, nameContains, nameIcontains, nameIexact, nameIn, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update a group
         * @param {string} authGroupHref 
         * @param {PatchedGroup} patchedGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(authGroupHref: string, patchedGroup: PatchedGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(authGroupHref, patchedGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect a group
         * @param {string} authGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(authGroupHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(authGroupHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update a group
         * @param {string} authGroupHref 
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(authGroupHref: string, group: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(authGroupHref, group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Delete a group
         * @param {string} authGroupHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(authGroupHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(authGroupHref, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Create a group
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(group: Group, options?: any): AxiosPromise<GroupResponse> {
            return localVarFp.create(group, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List groups
         * @param {number} [id] Filter results where id matches value
         * @param {Array<number>} [idIn] Filter results where id is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] Filter results where name matches value
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {string} [nameIexact] Filter results where name matches value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(id?: number, idIn?: Array<number>, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIexact?: string, nameIn?: Array<string>, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedGroupResponseList> {
            return localVarFp.list(id, idIn, limit, name, nameContains, nameIcontains, nameIexact, nameIn, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update a group
         * @param {string} authGroupHref 
         * @param {PatchedGroup} patchedGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(authGroupHref: string, patchedGroup: PatchedGroup, options?: any): AxiosPromise<GroupResponse> {
            return localVarFp.partialUpdate(authGroupHref, patchedGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect a group
         * @param {string} authGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(authGroupHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<GroupResponse> {
            return localVarFp.read(authGroupHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Update a group
         * @param {string} authGroupHref 
         * @param {Group} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(authGroupHref: string, group: Group, options?: any): AxiosPromise<GroupResponse> {
            return localVarFp.update(authGroupHref, group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Delete a group
     * @param {string} authGroupHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public _delete(authGroupHref: string, options?: any) {
        return GroupsApiFp(this.configuration)._delete(authGroupHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Create a group
     * @param {Group} group 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public create(group: Group, options?: any) {
        return GroupsApiFp(this.configuration).create(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary List groups
     * @param {number} [id] Filter results where id matches value
     * @param {Array<number>} [idIn] Filter results where id is in a comma-separated list of values
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] Filter results where name matches value
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {string} [nameIexact] Filter results where name matches value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public list(id?: number, idIn?: Array<number>, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIexact?: string, nameIn?: Array<string>, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsApiFp(this.configuration).list(id, idIn, limit, name, nameContains, nameIcontains, nameIexact, nameIn, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Update a group
     * @param {string} authGroupHref 
     * @param {PatchedGroup} patchedGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public partialUpdate(authGroupHref: string, patchedGroup: PatchedGroup, options?: any) {
        return GroupsApiFp(this.configuration).partialUpdate(authGroupHref, patchedGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Inspect a group
     * @param {string} authGroupHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public read(authGroupHref: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsApiFp(this.configuration).read(authGroupHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Group.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Update a group
     * @param {string} authGroupHref 
     * @param {Group} group 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public update(authGroupHref: string, group: Group, options?: any) {
        return GroupsApiFp(this.configuration).update(authGroupHref, group, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupsModelPermissionsApi - axios parameter creator
 * @export
 */
export const GroupsModelPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove a model permission from a group.
         * @summary Delete a permission
         * @param {string} authGroupsModelPermissionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (authGroupsModelPermissionHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupsModelPermissionHref' is not null or undefined
            assertParamExists('_delete', 'authGroupsModelPermissionHref', authGroupsModelPermissionHref)
            const localVarPath = `{auth_groups_model_permission_href}`
                .replace(`{${"auth_groups_model_permission_href"}}`, String(authGroupsModelPermissionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a model permission to a group.
         * @summary Create a permission
         * @param {string} authGroupHref 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (authGroupHref: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            assertParamExists('create', 'authGroupHref', authGroupHref)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('create', 'body', body)
            const localVarPath = `{auth_group_href}model_permissions/`
                .replace(`{${"auth_group_href"}}`, String(authGroupHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List group permissions.
         * @summary List permissions
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            assertParamExists('list', 'authGroupHref', authGroupHref)
            const localVarPath = `{auth_group_href}model_permissions/`
                .replace(`{${"auth_group_href"}}`, String(authGroupHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a model permission from a group.
         * @summary Inspect a permission
         * @param {string} authGroupsModelPermissionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (authGroupsModelPermissionHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupsModelPermissionHref' is not null or undefined
            assertParamExists('read', 'authGroupsModelPermissionHref', authGroupsModelPermissionHref)
            const localVarPath = `{auth_groups_model_permission_href}`
                .replace(`{${"auth_groups_model_permission_href"}}`, String(authGroupsModelPermissionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsModelPermissionsApi - functional programming interface
 * @export
 */
export const GroupsModelPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsModelPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Remove a model permission from a group.
         * @summary Delete a permission
         * @param {string} authGroupsModelPermissionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(authGroupsModelPermissionHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(authGroupsModelPermissionHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a model permission to a group.
         * @summary Create a permission
         * @param {string} authGroupHref 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(authGroupHref: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(authGroupHref, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List group permissions.
         * @summary List permissions
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPermissionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(authGroupHref, limit, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a model permission from a group.
         * @summary Inspect a permission
         * @param {string} authGroupsModelPermissionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(authGroupsModelPermissionHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(authGroupsModelPermissionHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsModelPermissionsApi - factory interface
 * @export
 */
export const GroupsModelPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsModelPermissionsApiFp(configuration)
    return {
        /**
         * Remove a model permission from a group.
         * @summary Delete a permission
         * @param {string} authGroupsModelPermissionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(authGroupsModelPermissionHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(authGroupsModelPermissionHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a model permission to a group.
         * @summary Create a permission
         * @param {string} authGroupHref 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(authGroupHref: string, body: object, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.create(authGroupHref, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List group permissions.
         * @summary List permissions
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedPermissionResponseList> {
            return localVarFp.list(authGroupHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a model permission from a group.
         * @summary Inspect a permission
         * @param {string} authGroupsModelPermissionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(authGroupsModelPermissionHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.read(authGroupsModelPermissionHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsModelPermissionsApi - object-oriented interface
 * @export
 * @class GroupsModelPermissionsApi
 * @extends {BaseAPI}
 */
export class GroupsModelPermissionsApi extends BaseAPI {
    /**
     * Remove a model permission from a group.
     * @summary Delete a permission
     * @param {string} authGroupsModelPermissionHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsModelPermissionsApi
     */
    public _delete(authGroupsModelPermissionHref: string, options?: any) {
        return GroupsModelPermissionsApiFp(this.configuration)._delete(authGroupsModelPermissionHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a model permission to a group.
     * @summary Create a permission
     * @param {string} authGroupHref 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsModelPermissionsApi
     */
    public create(authGroupHref: string, body: object, options?: any) {
        return GroupsModelPermissionsApiFp(this.configuration).create(authGroupHref, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List group permissions.
     * @summary List permissions
     * @param {string} authGroupHref 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsModelPermissionsApi
     */
    public list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsModelPermissionsApiFp(this.configuration).list(authGroupHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a model permission from a group.
     * @summary Inspect a permission
     * @param {string} authGroupsModelPermissionHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsModelPermissionsApi
     */
    public read(authGroupsModelPermissionHref: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsModelPermissionsApiFp(this.configuration).read(authGroupsModelPermissionHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupsObjectPermissionsApi - axios parameter creator
 * @export
 */
export const GroupsObjectPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove an object permission from a group.
         * @summary Delete a permission
         * @param {string} authGroupsObjectPermissionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (authGroupsObjectPermissionHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupsObjectPermissionHref' is not null or undefined
            assertParamExists('_delete', 'authGroupsObjectPermissionHref', authGroupsObjectPermissionHref)
            const localVarPath = `{auth_groups_object_permission_href}`
                .replace(`{${"auth_groups_object_permission_href"}}`, String(authGroupsObjectPermissionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an object permission to a group.
         * @summary Create a permission
         * @param {string} authGroupHref 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (authGroupHref: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            assertParamExists('create', 'authGroupHref', authGroupHref)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('create', 'body', body)
            const localVarPath = `{auth_group_href}object_permissions/`
                .replace(`{${"auth_group_href"}}`, String(authGroupHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List group object permissions.
         * @summary List permissions
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            assertParamExists('list', 'authGroupHref', authGroupHref)
            const localVarPath = `{auth_group_href}object_permissions/`
                .replace(`{${"auth_group_href"}}`, String(authGroupHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a model permission from a group.
         * @summary Inspect a permission
         * @param {string} authGroupsObjectPermissionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (authGroupsObjectPermissionHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupsObjectPermissionHref' is not null or undefined
            assertParamExists('read', 'authGroupsObjectPermissionHref', authGroupsObjectPermissionHref)
            const localVarPath = `{auth_groups_object_permission_href}`
                .replace(`{${"auth_groups_object_permission_href"}}`, String(authGroupsObjectPermissionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsObjectPermissionsApi - functional programming interface
 * @export
 */
export const GroupsObjectPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsObjectPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Remove an object permission from a group.
         * @summary Delete a permission
         * @param {string} authGroupsObjectPermissionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(authGroupsObjectPermissionHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(authGroupsObjectPermissionHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add an object permission to a group.
         * @summary Create a permission
         * @param {string} authGroupHref 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(authGroupHref: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(authGroupHref, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List group object permissions.
         * @summary List permissions
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPermissionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(authGroupHref, limit, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a model permission from a group.
         * @summary Inspect a permission
         * @param {string} authGroupsObjectPermissionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(authGroupsObjectPermissionHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(authGroupsObjectPermissionHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsObjectPermissionsApi - factory interface
 * @export
 */
export const GroupsObjectPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsObjectPermissionsApiFp(configuration)
    return {
        /**
         * Remove an object permission from a group.
         * @summary Delete a permission
         * @param {string} authGroupsObjectPermissionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(authGroupsObjectPermissionHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(authGroupsObjectPermissionHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an object permission to a group.
         * @summary Create a permission
         * @param {string} authGroupHref 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(authGroupHref: string, body: object, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.create(authGroupHref, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List group object permissions.
         * @summary List permissions
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedPermissionResponseList> {
            return localVarFp.list(authGroupHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a model permission from a group.
         * @summary Inspect a permission
         * @param {string} authGroupsObjectPermissionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(authGroupsObjectPermissionHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.read(authGroupsObjectPermissionHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsObjectPermissionsApi - object-oriented interface
 * @export
 * @class GroupsObjectPermissionsApi
 * @extends {BaseAPI}
 */
export class GroupsObjectPermissionsApi extends BaseAPI {
    /**
     * Remove an object permission from a group.
     * @summary Delete a permission
     * @param {string} authGroupsObjectPermissionHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsObjectPermissionsApi
     */
    public _delete(authGroupsObjectPermissionHref: string, options?: any) {
        return GroupsObjectPermissionsApiFp(this.configuration)._delete(authGroupsObjectPermissionHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an object permission to a group.
     * @summary Create a permission
     * @param {string} authGroupHref 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsObjectPermissionsApi
     */
    public create(authGroupHref: string, body: object, options?: any) {
        return GroupsObjectPermissionsApiFp(this.configuration).create(authGroupHref, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List group object permissions.
     * @summary List permissions
     * @param {string} authGroupHref 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsObjectPermissionsApi
     */
    public list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsObjectPermissionsApiFp(this.configuration).list(authGroupHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a model permission from a group.
     * @summary Inspect a permission
     * @param {string} authGroupsObjectPermissionHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsObjectPermissionsApi
     */
    public read(authGroupsObjectPermissionHref: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsObjectPermissionsApiFp(this.configuration).read(authGroupsObjectPermissionHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupsUsersApi - axios parameter creator
 * @export
 */
export const GroupsUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove a user from a group.
         * @summary Delete an user
         * @param {string} authGroupsUserHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (authGroupsUserHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupsUserHref' is not null or undefined
            assertParamExists('_delete', 'authGroupsUserHref', authGroupsUserHref)
            const localVarPath = `{auth_groups_user_href}`
                .replace(`{${"auth_groups_user_href"}}`, String(authGroupsUserHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a user to a group.
         * @summary Create an user
         * @param {string} authGroupHref 
         * @param {GroupUser} groupUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (authGroupHref: string, groupUser: GroupUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            assertParamExists('create', 'authGroupHref', authGroupHref)
            // verify required parameter 'groupUser' is not null or undefined
            assertParamExists('create', 'groupUser', groupUser)
            const localVarPath = `{auth_group_href}users/`
                .replace(`{${"auth_group_href"}}`, String(authGroupHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List group users.
         * @summary List users
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authGroupHref' is not null or undefined
            assertParamExists('list', 'authGroupHref', authGroupHref)
            const localVarPath = `{auth_group_href}users/`
                .replace(`{${"auth_group_href"}}`, String(authGroupHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsUsersApi - functional programming interface
 * @export
 */
export const GroupsUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Remove a user from a group.
         * @summary Delete an user
         * @param {string} authGroupsUserHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(authGroupsUserHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(authGroupsUserHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a user to a group.
         * @summary Create an user
         * @param {string} authGroupHref 
         * @param {GroupUser} groupUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(authGroupHref: string, groupUser: GroupUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(authGroupHref, groupUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List group users.
         * @summary List users
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGroupUserResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(authGroupHref, limit, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsUsersApi - factory interface
 * @export
 */
export const GroupsUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsUsersApiFp(configuration)
    return {
        /**
         * Remove a user from a group.
         * @summary Delete an user
         * @param {string} authGroupsUserHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(authGroupsUserHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(authGroupsUserHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a user to a group.
         * @summary Create an user
         * @param {string} authGroupHref 
         * @param {GroupUser} groupUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(authGroupHref: string, groupUser: GroupUser, options?: any): AxiosPromise<GroupUserResponse> {
            return localVarFp.create(authGroupHref, groupUser, options).then((request) => request(axios, basePath));
        },
        /**
         * List group users.
         * @summary List users
         * @param {string} authGroupHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedGroupUserResponseList> {
            return localVarFp.list(authGroupHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsUsersApi - object-oriented interface
 * @export
 * @class GroupsUsersApi
 * @extends {BaseAPI}
 */
export class GroupsUsersApi extends BaseAPI {
    /**
     * Remove a user from a group.
     * @summary Delete an user
     * @param {string} authGroupsUserHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsUsersApi
     */
    public _delete(authGroupsUserHref: string, options?: any) {
        return GroupsUsersApiFp(this.configuration)._delete(authGroupsUserHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a user to a group.
     * @summary Create an user
     * @param {string} authGroupHref 
     * @param {GroupUser} groupUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsUsersApi
     */
    public create(authGroupHref: string, groupUser: GroupUser, options?: any) {
        return GroupsUsersApiFp(this.configuration).create(authGroupHref, groupUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List group users.
     * @summary List users
     * @param {string} authGroupHref 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsUsersApi
     */
    public list(authGroupHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return GroupsUsersApiFp(this.configuration).list(authGroupHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImportersPulpApi - axios parameter creator
 * @export
 */
export const ImportersPulpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for PulpImporters.
         * @summary Delete a pulp importer
         * @param {string} pulpImporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (pulpImporterHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporterHref' is not null or undefined
            assertParamExists('_delete', 'pulpImporterHref', pulpImporterHref)
            const localVarPath = `{pulp_importer_href}`
                .replace(`{${"pulp_importer_href"}}`, String(pulpImporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Create a pulp importer
         * @param {PulpImporter} pulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (pulpImporter: PulpImporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporter' is not null or undefined
            assertParamExists('create', 'pulpImporter', pulpImporter)
            const localVarPath = `/pulp/api/v3/importers/core/pulp/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pulpImporter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary List pulp importers
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/importers/core/pulp/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Update a pulp importer
         * @param {string} pulpImporterHref 
         * @param {PatchedPulpImporter} patchedPulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (pulpImporterHref: string, patchedPulpImporter: PatchedPulpImporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporterHref' is not null or undefined
            assertParamExists('partialUpdate', 'pulpImporterHref', pulpImporterHref)
            // verify required parameter 'patchedPulpImporter' is not null or undefined
            assertParamExists('partialUpdate', 'patchedPulpImporter', patchedPulpImporter)
            const localVarPath = `{pulp_importer_href}`
                .replace(`{${"pulp_importer_href"}}`, String(pulpImporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPulpImporter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Inspect a pulp importer
         * @param {string} pulpImporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (pulpImporterHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporterHref' is not null or undefined
            assertParamExists('read', 'pulpImporterHref', pulpImporterHref)
            const localVarPath = `{pulp_importer_href}`
                .replace(`{${"pulp_importer_href"}}`, String(pulpImporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Update a pulp importer
         * @param {string} pulpImporterHref 
         * @param {PulpImporter} pulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (pulpImporterHref: string, pulpImporter: PulpImporter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporterHref' is not null or undefined
            assertParamExists('update', 'pulpImporterHref', pulpImporterHref)
            // verify required parameter 'pulpImporter' is not null or undefined
            assertParamExists('update', 'pulpImporter', pulpImporter)
            const localVarPath = `{pulp_importer_href}`
                .replace(`{${"pulp_importer_href"}}`, String(pulpImporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pulpImporter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportersPulpApi - functional programming interface
 * @export
 */
export const ImportersPulpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportersPulpApiAxiosParamCreator(configuration)
    return {
        /**
         * ViewSet for PulpImporters.
         * @summary Delete a pulp importer
         * @param {string} pulpImporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(pulpImporterHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(pulpImporterHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Create a pulp importer
         * @param {PulpImporter} pulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(pulpImporter: PulpImporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpImporterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(pulpImporter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for PulpImporters.
         * @summary List pulp importers
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPulpImporterResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Update a pulp importer
         * @param {string} pulpImporterHref 
         * @param {PatchedPulpImporter} patchedPulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(pulpImporterHref: string, patchedPulpImporter: PatchedPulpImporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpImporterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(pulpImporterHref, patchedPulpImporter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Inspect a pulp importer
         * @param {string} pulpImporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(pulpImporterHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpImporterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(pulpImporterHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Update a pulp importer
         * @param {string} pulpImporterHref 
         * @param {PulpImporter} pulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(pulpImporterHref: string, pulpImporter: PulpImporter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpImporterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(pulpImporterHref, pulpImporter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImportersPulpApi - factory interface
 * @export
 */
export const ImportersPulpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportersPulpApiFp(configuration)
    return {
        /**
         * ViewSet for PulpImporters.
         * @summary Delete a pulp importer
         * @param {string} pulpImporterHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(pulpImporterHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(pulpImporterHref, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Create a pulp importer
         * @param {PulpImporter} pulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(pulpImporter: PulpImporter, options?: any): AxiosPromise<PulpImporterResponse> {
            return localVarFp.create(pulpImporter, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImporters.
         * @summary List pulp importers
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedPulpImporterResponseList> {
            return localVarFp.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Update a pulp importer
         * @param {string} pulpImporterHref 
         * @param {PatchedPulpImporter} patchedPulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(pulpImporterHref: string, patchedPulpImporter: PatchedPulpImporter, options?: any): AxiosPromise<PulpImporterResponse> {
            return localVarFp.partialUpdate(pulpImporterHref, patchedPulpImporter, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Inspect a pulp importer
         * @param {string} pulpImporterHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(pulpImporterHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PulpImporterResponse> {
            return localVarFp.read(pulpImporterHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImporters.
         * @summary Update a pulp importer
         * @param {string} pulpImporterHref 
         * @param {PulpImporter} pulpImporter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(pulpImporterHref: string, pulpImporter: PulpImporter, options?: any): AxiosPromise<PulpImporterResponse> {
            return localVarFp.update(pulpImporterHref, pulpImporter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportersPulpApi - object-oriented interface
 * @export
 * @class ImportersPulpApi
 * @extends {BaseAPI}
 */
export class ImportersPulpApi extends BaseAPI {
    /**
     * ViewSet for PulpImporters.
     * @summary Delete a pulp importer
     * @param {string} pulpImporterHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpApi
     */
    public _delete(pulpImporterHref: string, options?: any) {
        return ImportersPulpApiFp(this.configuration)._delete(pulpImporterHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImporters.
     * @summary Create a pulp importer
     * @param {PulpImporter} pulpImporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpApi
     */
    public create(pulpImporter: PulpImporter, options?: any) {
        return ImportersPulpApiFp(this.configuration).create(pulpImporter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImporters.
     * @summary List pulp importers
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ImportersPulpApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImporters.
     * @summary Update a pulp importer
     * @param {string} pulpImporterHref 
     * @param {PatchedPulpImporter} patchedPulpImporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpApi
     */
    public partialUpdate(pulpImporterHref: string, patchedPulpImporter: PatchedPulpImporter, options?: any) {
        return ImportersPulpApiFp(this.configuration).partialUpdate(pulpImporterHref, patchedPulpImporter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImporters.
     * @summary Inspect a pulp importer
     * @param {string} pulpImporterHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpApi
     */
    public read(pulpImporterHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ImportersPulpApiFp(this.configuration).read(pulpImporterHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImporters.
     * @summary Update a pulp importer
     * @param {string} pulpImporterHref 
     * @param {PulpImporter} pulpImporter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpApi
     */
    public update(pulpImporterHref: string, pulpImporter: PulpImporter, options?: any) {
        return ImportersPulpApiFp(this.configuration).update(pulpImporterHref, pulpImporter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImportersPulpImportCheckApi - axios parameter creator
 * @export
 */
export const ImportersPulpImportCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Evaluates validity of proposed PulpImport parameters \'toc\', \'path\', and \'repo_mapping\'.  * Checks that toc, path are in ALLOWED_IMPORT_PATHS * if ALLOWED:   * Checks that toc, path exist and are readable   * If toc specified, checks that containing dir is writeable * Checks that repo_mapping is valid JSON
         * @summary Validate the parameters to be used for a PulpImport call
         * @param {PulpImportCheck} pulpImportCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pulpImportCheckPost: async (pulpImportCheck: PulpImportCheck, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImportCheck' is not null or undefined
            assertParamExists('pulpImportCheckPost', 'pulpImportCheck', pulpImportCheck)
            const localVarPath = `/pulp/api/v3/importers/core/pulp/import-check/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pulpImportCheck, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportersPulpImportCheckApi - functional programming interface
 * @export
 */
export const ImportersPulpImportCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportersPulpImportCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * Evaluates validity of proposed PulpImport parameters \'toc\', \'path\', and \'repo_mapping\'.  * Checks that toc, path are in ALLOWED_IMPORT_PATHS * if ALLOWED:   * Checks that toc, path exist and are readable   * If toc specified, checks that containing dir is writeable * Checks that repo_mapping is valid JSON
         * @summary Validate the parameters to be used for a PulpImport call
         * @param {PulpImportCheck} pulpImportCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pulpImportCheckPost(pulpImportCheck: PulpImportCheck, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PulpImportCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pulpImportCheckPost(pulpImportCheck, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImportersPulpImportCheckApi - factory interface
 * @export
 */
export const ImportersPulpImportCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportersPulpImportCheckApiFp(configuration)
    return {
        /**
         * Evaluates validity of proposed PulpImport parameters \'toc\', \'path\', and \'repo_mapping\'.  * Checks that toc, path are in ALLOWED_IMPORT_PATHS * if ALLOWED:   * Checks that toc, path exist and are readable   * If toc specified, checks that containing dir is writeable * Checks that repo_mapping is valid JSON
         * @summary Validate the parameters to be used for a PulpImport call
         * @param {PulpImportCheck} pulpImportCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pulpImportCheckPost(pulpImportCheck: PulpImportCheck, options?: any): AxiosPromise<PulpImportCheckResponse> {
            return localVarFp.pulpImportCheckPost(pulpImportCheck, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportersPulpImportCheckApi - object-oriented interface
 * @export
 * @class ImportersPulpImportCheckApi
 * @extends {BaseAPI}
 */
export class ImportersPulpImportCheckApi extends BaseAPI {
    /**
     * Evaluates validity of proposed PulpImport parameters \'toc\', \'path\', and \'repo_mapping\'.  * Checks that toc, path are in ALLOWED_IMPORT_PATHS * if ALLOWED:   * Checks that toc, path exist and are readable   * If toc specified, checks that containing dir is writeable * Checks that repo_mapping is valid JSON
     * @summary Validate the parameters to be used for a PulpImport call
     * @param {PulpImportCheck} pulpImportCheck 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpImportCheckApi
     */
    public pulpImportCheckPost(pulpImportCheck: PulpImportCheck, options?: any) {
        return ImportersPulpImportCheckApiFp(this.configuration).pulpImportCheckPost(pulpImportCheck, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImportersPulpImportsApi - axios parameter creator
 * @export
 */
export const ImportersPulpImportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for PulpImports.
         * @summary Delete a pulp import
         * @param {string} pulpPulpImportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (pulpPulpImportHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpPulpImportHref' is not null or undefined
            assertParamExists('_delete', 'pulpPulpImportHref', pulpPulpImportHref)
            const localVarPath = `{pulp_pulp_import_href}`
                .replace(`{${"pulp_pulp_import_href"}}`, String(pulpPulpImportHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to import a Pulp export.
         * @summary Create a pulp import
         * @param {string} pulpImporterHref 
         * @param {PulpImport} pulpImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (pulpImporterHref: string, pulpImport: PulpImport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporterHref' is not null or undefined
            assertParamExists('create', 'pulpImporterHref', pulpImporterHref)
            // verify required parameter 'pulpImport' is not null or undefined
            assertParamExists('create', 'pulpImport', pulpImport)
            const localVarPath = `{pulp_importer_href}imports/`
                .replace(`{${"pulp_importer_href"}}`, String(pulpImporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pulpImport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImports.
         * @summary List pulp imports
         * @param {string} pulpImporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (pulpImporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpImporterHref' is not null or undefined
            assertParamExists('list', 'pulpImporterHref', pulpImporterHref)
            const localVarPath = `{pulp_importer_href}imports/`
                .replace(`{${"pulp_importer_href"}}`, String(pulpImporterHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for PulpImports.
         * @summary Inspect a pulp import
         * @param {string} pulpPulpImportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (pulpPulpImportHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pulpPulpImportHref' is not null or undefined
            assertParamExists('read', 'pulpPulpImportHref', pulpPulpImportHref)
            const localVarPath = `{pulp_pulp_import_href}`
                .replace(`{${"pulp_pulp_import_href"}}`, String(pulpPulpImportHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportersPulpImportsApi - functional programming interface
 * @export
 */
export const ImportersPulpImportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportersPulpImportsApiAxiosParamCreator(configuration)
    return {
        /**
         * ViewSet for PulpImports.
         * @summary Delete a pulp import
         * @param {string} pulpPulpImportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(pulpPulpImportHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(pulpPulpImportHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous task to import a Pulp export.
         * @summary Create a pulp import
         * @param {string} pulpImporterHref 
         * @param {PulpImport} pulpImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(pulpImporterHref: string, pulpImport: PulpImport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(pulpImporterHref, pulpImport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for PulpImports.
         * @summary List pulp imports
         * @param {string} pulpImporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(pulpImporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedImportResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(pulpImporterHref, limit, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for PulpImports.
         * @summary Inspect a pulp import
         * @param {string} pulpPulpImportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(pulpPulpImportHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(pulpPulpImportHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImportersPulpImportsApi - factory interface
 * @export
 */
export const ImportersPulpImportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportersPulpImportsApiFp(configuration)
    return {
        /**
         * ViewSet for PulpImports.
         * @summary Delete a pulp import
         * @param {string} pulpPulpImportHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(pulpPulpImportHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(pulpPulpImportHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to import a Pulp export.
         * @summary Create a pulp import
         * @param {string} pulpImporterHref 
         * @param {PulpImport} pulpImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(pulpImporterHref: string, pulpImport: PulpImport, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.create(pulpImporterHref, pulpImport, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImports.
         * @summary List pulp imports
         * @param {string} pulpImporterHref 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(pulpImporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedImportResponseList> {
            return localVarFp.list(pulpImporterHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for PulpImports.
         * @summary Inspect a pulp import
         * @param {string} pulpPulpImportHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(pulpPulpImportHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<ImportResponse> {
            return localVarFp.read(pulpPulpImportHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportersPulpImportsApi - object-oriented interface
 * @export
 * @class ImportersPulpImportsApi
 * @extends {BaseAPI}
 */
export class ImportersPulpImportsApi extends BaseAPI {
    /**
     * ViewSet for PulpImports.
     * @summary Delete a pulp import
     * @param {string} pulpPulpImportHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpImportsApi
     */
    public _delete(pulpPulpImportHref: string, options?: any) {
        return ImportersPulpImportsApiFp(this.configuration)._delete(pulpPulpImportHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to import a Pulp export.
     * @summary Create a pulp import
     * @param {string} pulpImporterHref 
     * @param {PulpImport} pulpImport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpImportsApi
     */
    public create(pulpImporterHref: string, pulpImport: PulpImport, options?: any) {
        return ImportersPulpImportsApiFp(this.configuration).create(pulpImporterHref, pulpImport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImports.
     * @summary List pulp imports
     * @param {string} pulpImporterHref 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpImportsApi
     */
    public list(pulpImporterHref: string, limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return ImportersPulpImportsApiFp(this.configuration).list(pulpImporterHref, limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for PulpImports.
     * @summary Inspect a pulp import
     * @param {string} pulpPulpImportHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportersPulpImportsApi
     */
    public read(pulpPulpImportHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ImportersPulpImportsApiFp(this.configuration).read(pulpPulpImportHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrphansApi - axios parameter creator
 * @export
 */
export const OrphansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * DEPRECATED! Trigger an asynchronous task that deletes all orphaned content and artifacts. Use the `POST /pulp/api/v3/orphans/cleanup/` call instead.
         * @summary Delete orphans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/orphans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrphansApi - functional programming interface
 * @export
 */
export const OrphansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrphansApiAxiosParamCreator(configuration)
    return {
        /**
         * DEPRECATED! Trigger an asynchronous task that deletes all orphaned content and artifacts. Use the `POST /pulp/api/v3/orphans/cleanup/` call instead.
         * @summary Delete orphans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrphansApi - factory interface
 * @export
 */
export const OrphansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrphansApiFp(configuration)
    return {
        /**
         * DEPRECATED! Trigger an asynchronous task that deletes all orphaned content and artifacts. Use the `POST /pulp/api/v3/orphans/cleanup/` call instead.
         * @summary Delete orphans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp._delete(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrphansApi - object-oriented interface
 * @export
 * @class OrphansApi
 * @extends {BaseAPI}
 */
export class OrphansApi extends BaseAPI {
    /**
     * DEPRECATED! Trigger an asynchronous task that deletes all orphaned content and artifacts. Use the `POST /pulp/api/v3/orphans/cleanup/` call instead.
     * @summary Delete orphans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrphansApi
     */
    public _delete(options?: any) {
        return OrphansApiFp(this.configuration)._delete(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrphansCleanupApi - axios parameter creator
 * @export
 */
export const OrphansCleanupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous orphan cleanup operation.
         * @param {OrphansCleanup} orphansCleanup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanup: async (orphansCleanup: OrphansCleanup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orphansCleanup' is not null or undefined
            assertParamExists('cleanup', 'orphansCleanup', orphansCleanup)
            const localVarPath = `/pulp/api/v3/orphans/cleanup/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orphansCleanup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrphansCleanupApi - functional programming interface
 * @export
 */
export const OrphansCleanupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrphansCleanupApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous orphan cleanup operation.
         * @param {OrphansCleanup} orphansCleanup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanup(orphansCleanup: OrphansCleanup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanup(orphansCleanup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrphansCleanupApi - factory interface
 * @export
 */
export const OrphansCleanupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrphansCleanupApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous orphan cleanup operation.
         * @param {OrphansCleanup} orphansCleanup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanup(orphansCleanup: OrphansCleanup, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.cleanup(orphansCleanup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrphansCleanupApi - object-oriented interface
 * @export
 * @class OrphansCleanupApi
 * @extends {BaseAPI}
 */
export class OrphansCleanupApi extends BaseAPI {
    /**
     * Trigger an asynchronous orphan cleanup operation.
     * @param {OrphansCleanup} orphansCleanup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrphansCleanupApi
     */
    public cleanup(orphansCleanup: OrphansCleanup, options?: any) {
        return OrphansCleanupApiFp(this.configuration).cleanup(orphansCleanup, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicationsApi - axios parameter creator
 * @export
 */
export const PublicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List publications
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (content?: string, contentIn?: string, limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, repositoryVersion?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/publications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (contentIn !== undefined) {
                localVarQueryParameter['content__in'] = contentIn;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpCreated !== undefined) {
                localVarQueryParameter['pulp_created'] = (pulpCreated as any instanceof Date) ?
                    (pulpCreated as any).toISOString() :
                    pulpCreated;
            }

            if (pulpCreatedGt !== undefined) {
                localVarQueryParameter['pulp_created__gt'] = (pulpCreatedGt as any instanceof Date) ?
                    (pulpCreatedGt as any).toISOString() :
                    pulpCreatedGt;
            }

            if (pulpCreatedGte !== undefined) {
                localVarQueryParameter['pulp_created__gte'] = (pulpCreatedGte as any instanceof Date) ?
                    (pulpCreatedGte as any).toISOString() :
                    pulpCreatedGte;
            }

            if (pulpCreatedLt !== undefined) {
                localVarQueryParameter['pulp_created__lt'] = (pulpCreatedLt as any instanceof Date) ?
                    (pulpCreatedLt as any).toISOString() :
                    pulpCreatedLt;
            }

            if (pulpCreatedLte !== undefined) {
                localVarQueryParameter['pulp_created__lte'] = (pulpCreatedLte as any instanceof Date) ?
                    (pulpCreatedLte as any).toISOString() :
                    pulpCreatedLte;
            }

            if (pulpCreatedRange) {
                localVarQueryParameter['pulp_created__range'] = pulpCreatedRange.join(COLLECTION_FORMATS.csv);
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicationsApi - functional programming interface
 * @export
 */
export const PublicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List publications
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(content?: string, contentIn?: string, limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, repositoryVersion?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPublicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(content, contentIn, limit, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, repositoryVersion, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicationsApi - factory interface
 * @export
 */
export const PublicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicationsApiFp(configuration)
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List publications
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(content?: string, contentIn?: string, limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, repositoryVersion?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedPublicationResponseList> {
            return localVarFp.list(content, contentIn, limit, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, repositoryVersion, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicationsApi - object-oriented interface
 * @export
 * @class PublicationsApi
 * @extends {BaseAPI}
 */
export class PublicationsApi extends BaseAPI {
    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary List publications
     * @param {string} [content] Content Unit referenced by HREF
     * @param {string} [contentIn] Content Unit referenced by HREF
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
     * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
     * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
     * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
     * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
     * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsApi
     */
    public list(content?: string, contentIn?: string, limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, repositoryVersion?: string, fields?: string, excludeFields?: string, options?: any) {
        return PublicationsApiFp(this.configuration).list(content, contentIn, limit, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, repositoryVersion, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepairApi - axios parameter creator
 * @export
 */
export const RepairApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task that checks for missing or corrupted artifacts, and attempts to redownload them.
         * @summary Repair Artifact Storage
         * @param {Repair} repair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: async (repair: Repair, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repair' is not null or undefined
            assertParamExists('post', 'repair', repair)
            const localVarPath = `/pulp/api/v3/repair/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepairApi - functional programming interface
 * @export
 */
export const RepairApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepairApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous task that checks for missing or corrupted artifacts, and attempts to redownload them.
         * @summary Repair Artifact Storage
         * @param {Repair} repair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async post(repair: Repair, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.post(repair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepairApi - factory interface
 * @export
 */
export const RepairApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepairApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous task that checks for missing or corrupted artifacts, and attempts to redownload them.
         * @summary Repair Artifact Storage
         * @param {Repair} repair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(repair: Repair, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.post(repair, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepairApi - object-oriented interface
 * @export
 * @class RepairApi
 * @extends {BaseAPI}
 */
export class RepairApi extends BaseAPI {
    /**
     * Trigger an asynchronous task that checks for missing or corrupted artifacts, and attempts to redownload them.
     * @summary Repair Artifact Storage
     * @param {Repair} repair 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepairApi
     */
    public post(repair: Repair, options?: any) {
        return RepairApiFp(this.configuration).post(repair, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoriesApi - axios parameter creator
 * @export
 */
export const RepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint to list all repositories.
         * @summary List repositories
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/repositories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpLabelSelect !== undefined) {
                localVarQueryParameter['pulp_label_select'] = pulpLabelSelect;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesApi - functional programming interface
 * @export
 */
export const RepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint to list all repositories.
         * @summary List repositories
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoriesApi - factory interface
 * @export
 */
export const RepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoriesApiFp(configuration)
    return {
        /**
         * Endpoint to list all repositories.
         * @summary List repositories
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedRepositoryResponseList> {
            return localVarFp.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesApi - object-oriented interface
 * @export
 * @class RepositoriesApi
 * @extends {BaseAPI}
 */
export class RepositoriesApi extends BaseAPI {
    /**
     * Endpoint to list all repositories.
     * @summary List repositories
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpLabelSelect] Filter labels by search string
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoriesReclaimSpaceApi - axios parameter creator
 * @export
 */
export const RepositoriesReclaimSpaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous space reclaim operation.
         * @param {ReclaimSpace} reclaimSpace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reclaim: async (reclaimSpace: ReclaimSpace, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'reclaimSpace' is not null or undefined
            assertParamExists('reclaim', 'reclaimSpace', reclaimSpace)
            const localVarPath = `/pulp/api/v3/repositories/reclaim_space/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reclaimSpace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesReclaimSpaceApi - functional programming interface
 * @export
 */
export const RepositoriesReclaimSpaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoriesReclaimSpaceApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous space reclaim operation.
         * @param {ReclaimSpace} reclaimSpace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reclaim(reclaimSpace: ReclaimSpace, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reclaim(reclaimSpace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoriesReclaimSpaceApi - factory interface
 * @export
 */
export const RepositoriesReclaimSpaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoriesReclaimSpaceApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous space reclaim operation.
         * @param {ReclaimSpace} reclaimSpace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reclaim(reclaimSpace: ReclaimSpace, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.reclaim(reclaimSpace, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesReclaimSpaceApi - object-oriented interface
 * @export
 * @class RepositoriesReclaimSpaceApi
 * @extends {BaseAPI}
 */
export class RepositoriesReclaimSpaceApi extends BaseAPI {
    /**
     * Trigger an asynchronous space reclaim operation.
     * @param {ReclaimSpace} reclaimSpace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesReclaimSpaceApi
     */
    public reclaim(reclaimSpace: ReclaimSpace, options?: any) {
        return RepositoriesReclaimSpaceApiFp(this.configuration).reclaim(reclaimSpace, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoryVersionsApi - axios parameter creator
 * @export
 */
export const RepositoryVersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List repository versions
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [number] 
         * @param {number} [numberGt] Filter results where number is greater than value
         * @param {number} [numberGte] Filter results where number is greater than or equal to value
         * @param {number} [numberLt] Filter results where number is less than value
         * @param {number} [numberLte] Filter results where number is less than or equal to value
         * @param {Array<number>} [numberRange] Filter results where number is between two comma separated values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (content?: string, contentIn?: string, limit?: number, number?: number, numberGt?: number, numberGte?: number, numberLt?: number, numberLte?: number, numberRange?: Array<number>, offset?: number, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/repository_versions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (contentIn !== undefined) {
                localVarQueryParameter['content__in'] = contentIn;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (numberGt !== undefined) {
                localVarQueryParameter['number__gt'] = numberGt;
            }

            if (numberGte !== undefined) {
                localVarQueryParameter['number__gte'] = numberGte;
            }

            if (numberLt !== undefined) {
                localVarQueryParameter['number__lt'] = numberLt;
            }

            if (numberLte !== undefined) {
                localVarQueryParameter['number__lte'] = numberLte;
            }

            if (numberRange) {
                localVarQueryParameter['number__range'] = numberRange.join(COLLECTION_FORMATS.csv);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pulpCreated !== undefined) {
                localVarQueryParameter['pulp_created'] = (pulpCreated as any instanceof Date) ?
                    (pulpCreated as any).toISOString() :
                    pulpCreated;
            }

            if (pulpCreatedGt !== undefined) {
                localVarQueryParameter['pulp_created__gt'] = (pulpCreatedGt as any instanceof Date) ?
                    (pulpCreatedGt as any).toISOString() :
                    pulpCreatedGt;
            }

            if (pulpCreatedGte !== undefined) {
                localVarQueryParameter['pulp_created__gte'] = (pulpCreatedGte as any instanceof Date) ?
                    (pulpCreatedGte as any).toISOString() :
                    pulpCreatedGte;
            }

            if (pulpCreatedLt !== undefined) {
                localVarQueryParameter['pulp_created__lt'] = (pulpCreatedLt as any instanceof Date) ?
                    (pulpCreatedLt as any).toISOString() :
                    pulpCreatedLt;
            }

            if (pulpCreatedLte !== undefined) {
                localVarQueryParameter['pulp_created__lte'] = (pulpCreatedLte as any instanceof Date) ?
                    (pulpCreatedLte as any).toISOString() :
                    pulpCreatedLte;
            }

            if (pulpCreatedRange) {
                localVarQueryParameter['pulp_created__range'] = pulpCreatedRange.join(COLLECTION_FORMATS.csv);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryVersionsApi - functional programming interface
 * @export
 */
export const RepositoryVersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryVersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List repository versions
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [number] 
         * @param {number} [numberGt] Filter results where number is greater than value
         * @param {number} [numberGte] Filter results where number is greater than or equal to value
         * @param {number} [numberLt] Filter results where number is less than value
         * @param {number} [numberLte] Filter results where number is less than or equal to value
         * @param {Array<number>} [numberRange] Filter results where number is between two comma separated values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(content?: string, contentIn?: string, limit?: number, number?: number, numberGt?: number, numberGte?: number, numberLt?: number, numberLte?: number, numberRange?: Array<number>, offset?: number, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositoryVersionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(content, contentIn, limit, number, numberGt, numberGte, numberLt, numberLte, numberRange, offset, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoryVersionsApi - factory interface
 * @export
 */
export const RepositoryVersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryVersionsApiFp(configuration)
    return {
        /**
         * 
         * @summary List repository versions
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [number] 
         * @param {number} [numberGt] Filter results where number is greater than value
         * @param {number} [numberGte] Filter results where number is greater than or equal to value
         * @param {number} [numberLt] Filter results where number is less than value
         * @param {number} [numberLte] Filter results where number is less than or equal to value
         * @param {Array<number>} [numberRange] Filter results where number is between two comma separated values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(content?: string, contentIn?: string, limit?: number, number?: number, numberGt?: number, numberGte?: number, numberLt?: number, numberLte?: number, numberRange?: Array<number>, offset?: number, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedRepositoryVersionResponseList> {
            return localVarFp.list(content, contentIn, limit, number, numberGt, numberGte, numberLt, numberLte, numberRange, offset, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryVersionsApi - object-oriented interface
 * @export
 * @class RepositoryVersionsApi
 * @extends {BaseAPI}
 */
export class RepositoryVersionsApi extends BaseAPI {
    /**
     * 
     * @summary List repository versions
     * @param {string} [content] Content Unit referenced by HREF
     * @param {string} [contentIn] Content Unit referenced by HREF
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [number] 
     * @param {number} [numberGt] Filter results where number is greater than value
     * @param {number} [numberGte] Filter results where number is greater than or equal to value
     * @param {number} [numberLt] Filter results where number is less than value
     * @param {number} [numberLte] Filter results where number is less than or equal to value
     * @param {Array<number>} [numberRange] Filter results where number is between two comma separated values
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
     * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
     * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
     * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
     * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
     * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryVersionsApi
     */
    public list(content?: string, contentIn?: string, limit?: number, number?: number, numberGt?: number, numberGte?: number, numberLt?: number, numberLte?: number, numberRange?: Array<number>, offset?: number, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any) {
        return RepositoryVersionsApiFp(this.configuration).list(content, contentIn, limit, number, numberGt, numberGte, numberLt, numberLte, numberRange, offset, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SigningServicesApi - axios parameter creator
 * @export
 */
export const SigningServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A ViewSet that supports browsing of existing signing services.
         * @summary List signing services
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/signing-services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet that supports browsing of existing signing services.
         * @summary Inspect a signing service
         * @param {string} signingServiceHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (signingServiceHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signingServiceHref' is not null or undefined
            assertParamExists('read', 'signingServiceHref', signingServiceHref)
            const localVarPath = `{signing_service_href}`
                .replace(`{${"signing_service_href"}}`, String(signingServiceHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SigningServicesApi - functional programming interface
 * @export
 */
export const SigningServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SigningServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * A ViewSet that supports browsing of existing signing services.
         * @summary List signing services
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSigningServiceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet that supports browsing of existing signing services.
         * @summary Inspect a signing service
         * @param {string} signingServiceHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(signingServiceHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigningServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(signingServiceHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SigningServicesApi - factory interface
 * @export
 */
export const SigningServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SigningServicesApiFp(configuration)
    return {
        /**
         * A ViewSet that supports browsing of existing signing services.
         * @summary List signing services
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedSigningServiceResponseList> {
            return localVarFp.list(limit, name, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet that supports browsing of existing signing services.
         * @summary Inspect a signing service
         * @param {string} signingServiceHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(signingServiceHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<SigningServiceResponse> {
            return localVarFp.read(signingServiceHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SigningServicesApi - object-oriented interface
 * @export
 * @class SigningServicesApi
 * @extends {BaseAPI}
 */
export class SigningServicesApi extends BaseAPI {
    /**
     * A ViewSet that supports browsing of existing signing services.
     * @summary List signing services
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningServicesApi
     */
    public list(limit?: number, name?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return SigningServicesApiFp(this.configuration).list(limit, name, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet that supports browsing of existing signing services.
     * @summary Inspect a signing service
     * @param {string} signingServiceHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningServicesApi
     */
    public read(signingServiceHref: string, fields?: string, excludeFields?: string, options?: any) {
        return SigningServicesApiFp(this.configuration).read(signingServiceHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns status and app information about Pulp.  Information includes:  * version of pulpcore and loaded pulp plugins  * known workers  * known content apps  * database connection status  * redis connection status  * disk usage information
         * @summary Inspect status of Pulp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusRead: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns status and app information about Pulp.  Information includes:  * version of pulpcore and loaded pulp plugins  * known workers  * known content apps  * database connection status  * redis connection status  * disk usage information
         * @summary Inspect status of Pulp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusRead(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusRead(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * Returns status and app information about Pulp.  Information includes:  * version of pulpcore and loaded pulp plugins  * known workers  * known content apps  * database connection status  * redis connection status  * disk usage information
         * @summary Inspect status of Pulp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusRead(options?: any): AxiosPromise<StatusResponse> {
            return localVarFp.statusRead(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Returns status and app information about Pulp.  Information includes:  * version of pulpcore and loaded pulp plugins  * known workers  * known content apps  * database connection status  * redis connection status  * disk usage information
     * @summary Inspect status of Pulp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusRead(options?: any) {
        return StatusApiFp(this.configuration).statusRead(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TaskGroupsApi - axios parameter creator
 * @export
 */
export const TaskGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List task groups
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/task-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a task group
         * @param {string} taskGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (taskGroupHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskGroupHref' is not null or undefined
            assertParamExists('read', 'taskGroupHref', taskGroupHref)
            const localVarPath = `{task_group_href}`
                .replace(`{${"task_group_href"}}`, String(taskGroupHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskGroupsApi - functional programming interface
 * @export
 */
export const TaskGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List task groups
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTaskGroupResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a task group
         * @param {string} taskGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(taskGroupHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(taskGroupHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskGroupsApi - factory interface
 * @export
 */
export const TaskGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskGroupsApiFp(configuration)
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List task groups
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedTaskGroupResponseList> {
            return localVarFp.list(limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a task group
         * @param {string} taskGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(taskGroupHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<TaskGroupResponse> {
            return localVarFp.read(taskGroupHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskGroupsApi - object-oriented interface
 * @export
 * @class TaskGroupsApi
 * @extends {BaseAPI}
 */
export class TaskGroupsApi extends BaseAPI {
    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary List task groups
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGroupsApi
     */
    public list(limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return TaskGroupsApiFp(this.configuration).list(limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary Inspect a task group
     * @param {string} taskGroupHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGroupsApi
     */
    public read(taskGroupHref: string, fields?: string, excludeFields?: string, options?: any) {
        return TaskGroupsApiFp(this.configuration).read(taskGroupHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Delete a task
         * @param {string} taskHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (taskHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskHref' is not null or undefined
            assertParamExists('_delete', 'taskHref', taskHref)
            const localVarPath = `{task_href}`
                .replace(`{${"task_href"}}`, String(taskHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List tasks
         * @param {string} [childTasks] Foreign Key referenced by HREF
         * @param {string} [createdResources] 
         * @param {string} [finishedAt] ISO 8601 formatted dates are supported
         * @param {string} [finishedAtGt] Filter results where finished_at is greater than value
         * @param {string} [finishedAtGte] Filter results where finished_at is greater than or equal to value
         * @param {string} [finishedAtLt] Filter results where finished_at is less than value
         * @param {string} [finishedAtLte] Filter results where finished_at is less than or equal to value
         * @param {Array<string>} [finishedAtRange] Filter results where finished_at is between two comma separated values
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [loggingCid] 
         * @param {string} [loggingCidContains] Filter results where logging_cid contains value
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [parentTask] Foreign Key referenced by HREF
         * @param {Array<string>} [reservedResourcesRecord] 
         * @param {string} [startedAt] ISO 8601 formatted dates are supported
         * @param {string} [startedAtGt] Filter results where started_at is greater than value
         * @param {string} [startedAtGte] Filter results where started_at is greater than or equal to value
         * @param {string} [startedAtLt] Filter results where started_at is less than value
         * @param {string} [startedAtLte] Filter results where started_at is less than or equal to value
         * @param {Array<string>} [startedAtRange] Filter results where started_at is between two comma separated values
         * @param {'canceled' | 'canceling' | 'completed' | 'failed' | 'running' | 'skipped' | 'waiting'} [state] 
         * @param {Array<string>} [stateIn] Filter results where state is in a comma-separated list of values
         * @param {string} [taskGroup] Foreign Key referenced by HREF
         * @param {string} [worker] Foreign Key referenced by HREF
         * @param {Array<string>} [workerIn] Filter results where worker is in a comma-separated list of values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (childTasks?: string, createdResources?: string, finishedAt?: string, finishedAtGt?: string, finishedAtGte?: string, finishedAtLt?: string, finishedAtLte?: string, finishedAtRange?: Array<string>, limit?: number, loggingCid?: string, loggingCidContains?: string, name?: string, nameContains?: string, offset?: number, ordering?: string, parentTask?: string, reservedResourcesRecord?: Array<string>, startedAt?: string, startedAtGt?: string, startedAtGte?: string, startedAtLt?: string, startedAtLte?: string, startedAtRange?: Array<string>, state?: 'canceled' | 'canceling' | 'completed' | 'failed' | 'running' | 'skipped' | 'waiting', stateIn?: Array<string>, taskGroup?: string, worker?: string, workerIn?: Array<string>, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (childTasks !== undefined) {
                localVarQueryParameter['child_tasks'] = childTasks;
            }

            if (createdResources !== undefined) {
                localVarQueryParameter['created_resources'] = createdResources;
            }

            if (finishedAt !== undefined) {
                localVarQueryParameter['finished_at'] = (finishedAt as any instanceof Date) ?
                    (finishedAt as any).toISOString() :
                    finishedAt;
            }

            if (finishedAtGt !== undefined) {
                localVarQueryParameter['finished_at__gt'] = (finishedAtGt as any instanceof Date) ?
                    (finishedAtGt as any).toISOString() :
                    finishedAtGt;
            }

            if (finishedAtGte !== undefined) {
                localVarQueryParameter['finished_at__gte'] = (finishedAtGte as any instanceof Date) ?
                    (finishedAtGte as any).toISOString() :
                    finishedAtGte;
            }

            if (finishedAtLt !== undefined) {
                localVarQueryParameter['finished_at__lt'] = (finishedAtLt as any instanceof Date) ?
                    (finishedAtLt as any).toISOString() :
                    finishedAtLt;
            }

            if (finishedAtLte !== undefined) {
                localVarQueryParameter['finished_at__lte'] = (finishedAtLte as any instanceof Date) ?
                    (finishedAtLte as any).toISOString() :
                    finishedAtLte;
            }

            if (finishedAtRange) {
                localVarQueryParameter['finished_at__range'] = finishedAtRange.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (loggingCid !== undefined) {
                localVarQueryParameter['logging_cid'] = loggingCid;
            }

            if (loggingCidContains !== undefined) {
                localVarQueryParameter['logging_cid__contains'] = loggingCidContains;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (parentTask !== undefined) {
                localVarQueryParameter['parent_task'] = parentTask;
            }

            if (reservedResourcesRecord) {
                localVarQueryParameter['reserved_resources_record'] = reservedResourcesRecord;
            }

            if (startedAt !== undefined) {
                localVarQueryParameter['started_at'] = (startedAt as any instanceof Date) ?
                    (startedAt as any).toISOString() :
                    startedAt;
            }

            if (startedAtGt !== undefined) {
                localVarQueryParameter['started_at__gt'] = (startedAtGt as any instanceof Date) ?
                    (startedAtGt as any).toISOString() :
                    startedAtGt;
            }

            if (startedAtGte !== undefined) {
                localVarQueryParameter['started_at__gte'] = (startedAtGte as any instanceof Date) ?
                    (startedAtGte as any).toISOString() :
                    startedAtGte;
            }

            if (startedAtLt !== undefined) {
                localVarQueryParameter['started_at__lt'] = (startedAtLt as any instanceof Date) ?
                    (startedAtLt as any).toISOString() :
                    startedAtLt;
            }

            if (startedAtLte !== undefined) {
                localVarQueryParameter['started_at__lte'] = (startedAtLte as any instanceof Date) ?
                    (startedAtLte as any).toISOString() :
                    startedAtLte;
            }

            if (startedAtRange) {
                localVarQueryParameter['started_at__range'] = startedAtRange.join(COLLECTION_FORMATS.csv);
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (stateIn) {
                localVarQueryParameter['state__in'] = stateIn.join(COLLECTION_FORMATS.csv);
            }

            if (taskGroup !== undefined) {
                localVarQueryParameter['task_group'] = taskGroup;
            }

            if (worker !== undefined) {
                localVarQueryParameter['worker'] = worker;
            }

            if (workerIn) {
                localVarQueryParameter['worker__in'] = workerIn.join(COLLECTION_FORMATS.csv);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a task
         * @param {string} taskHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (taskHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskHref' is not null or undefined
            assertParamExists('read', 'taskHref', taskHref)
            const localVarPath = `{task_href}`
                .replace(`{${"task_href"}}`, String(taskHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation cancels a task.
         * @summary Cancel a task
         * @param {string} taskHref 
         * @param {PatchedTaskCancel} patchedTaskCancel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCancel: async (taskHref: string, patchedTaskCancel: PatchedTaskCancel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskHref' is not null or undefined
            assertParamExists('tasksCancel', 'taskHref', taskHref)
            // verify required parameter 'patchedTaskCancel' is not null or undefined
            assertParamExists('tasksCancel', 'patchedTaskCancel', patchedTaskCancel)
            const localVarPath = `{task_href}`
                .replace(`{${"task_href"}}`, String(taskHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTaskCancel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Delete a task
         * @param {string} taskHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(taskHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(taskHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List tasks
         * @param {string} [childTasks] Foreign Key referenced by HREF
         * @param {string} [createdResources] 
         * @param {string} [finishedAt] ISO 8601 formatted dates are supported
         * @param {string} [finishedAtGt] Filter results where finished_at is greater than value
         * @param {string} [finishedAtGte] Filter results where finished_at is greater than or equal to value
         * @param {string} [finishedAtLt] Filter results where finished_at is less than value
         * @param {string} [finishedAtLte] Filter results where finished_at is less than or equal to value
         * @param {Array<string>} [finishedAtRange] Filter results where finished_at is between two comma separated values
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [loggingCid] 
         * @param {string} [loggingCidContains] Filter results where logging_cid contains value
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [parentTask] Foreign Key referenced by HREF
         * @param {Array<string>} [reservedResourcesRecord] 
         * @param {string} [startedAt] ISO 8601 formatted dates are supported
         * @param {string} [startedAtGt] Filter results where started_at is greater than value
         * @param {string} [startedAtGte] Filter results where started_at is greater than or equal to value
         * @param {string} [startedAtLt] Filter results where started_at is less than value
         * @param {string} [startedAtLte] Filter results where started_at is less than or equal to value
         * @param {Array<string>} [startedAtRange] Filter results where started_at is between two comma separated values
         * @param {'canceled' | 'canceling' | 'completed' | 'failed' | 'running' | 'skipped' | 'waiting'} [state] 
         * @param {Array<string>} [stateIn] Filter results where state is in a comma-separated list of values
         * @param {string} [taskGroup] Foreign Key referenced by HREF
         * @param {string} [worker] Foreign Key referenced by HREF
         * @param {Array<string>} [workerIn] Filter results where worker is in a comma-separated list of values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(childTasks?: string, createdResources?: string, finishedAt?: string, finishedAtGt?: string, finishedAtGte?: string, finishedAtLt?: string, finishedAtLte?: string, finishedAtRange?: Array<string>, limit?: number, loggingCid?: string, loggingCidContains?: string, name?: string, nameContains?: string, offset?: number, ordering?: string, parentTask?: string, reservedResourcesRecord?: Array<string>, startedAt?: string, startedAtGt?: string, startedAtGte?: string, startedAtLt?: string, startedAtLte?: string, startedAtRange?: Array<string>, state?: 'canceled' | 'canceling' | 'completed' | 'failed' | 'running' | 'skipped' | 'waiting', stateIn?: Array<string>, taskGroup?: string, worker?: string, workerIn?: Array<string>, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTaskResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(childTasks, createdResources, finishedAt, finishedAtGt, finishedAtGte, finishedAtLt, finishedAtLte, finishedAtRange, limit, loggingCid, loggingCidContains, name, nameContains, offset, ordering, parentTask, reservedResourcesRecord, startedAt, startedAtGt, startedAtGte, startedAtLt, startedAtLte, startedAtRange, state, stateIn, taskGroup, worker, workerIn, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a task
         * @param {string} taskHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(taskHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(taskHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This operation cancels a task.
         * @summary Cancel a task
         * @param {string} taskHref 
         * @param {PatchedTaskCancel} patchedTaskCancel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCancel(taskHref: string, patchedTaskCancel: PatchedTaskCancel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCancel(taskHref, patchedTaskCancel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Delete a task
         * @param {string} taskHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(taskHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(taskHref, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List tasks
         * @param {string} [childTasks] Foreign Key referenced by HREF
         * @param {string} [createdResources] 
         * @param {string} [finishedAt] ISO 8601 formatted dates are supported
         * @param {string} [finishedAtGt] Filter results where finished_at is greater than value
         * @param {string} [finishedAtGte] Filter results where finished_at is greater than or equal to value
         * @param {string} [finishedAtLt] Filter results where finished_at is less than value
         * @param {string} [finishedAtLte] Filter results where finished_at is less than or equal to value
         * @param {Array<string>} [finishedAtRange] Filter results where finished_at is between two comma separated values
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [loggingCid] 
         * @param {string} [loggingCidContains] Filter results where logging_cid contains value
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [parentTask] Foreign Key referenced by HREF
         * @param {Array<string>} [reservedResourcesRecord] 
         * @param {string} [startedAt] ISO 8601 formatted dates are supported
         * @param {string} [startedAtGt] Filter results where started_at is greater than value
         * @param {string} [startedAtGte] Filter results where started_at is greater than or equal to value
         * @param {string} [startedAtLt] Filter results where started_at is less than value
         * @param {string} [startedAtLte] Filter results where started_at is less than or equal to value
         * @param {Array<string>} [startedAtRange] Filter results where started_at is between two comma separated values
         * @param {'canceled' | 'canceling' | 'completed' | 'failed' | 'running' | 'skipped' | 'waiting'} [state] 
         * @param {Array<string>} [stateIn] Filter results where state is in a comma-separated list of values
         * @param {string} [taskGroup] Foreign Key referenced by HREF
         * @param {string} [worker] Foreign Key referenced by HREF
         * @param {Array<string>} [workerIn] Filter results where worker is in a comma-separated list of values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(childTasks?: string, createdResources?: string, finishedAt?: string, finishedAtGt?: string, finishedAtGte?: string, finishedAtLt?: string, finishedAtLte?: string, finishedAtRange?: Array<string>, limit?: number, loggingCid?: string, loggingCidContains?: string, name?: string, nameContains?: string, offset?: number, ordering?: string, parentTask?: string, reservedResourcesRecord?: Array<string>, startedAt?: string, startedAtGt?: string, startedAtGte?: string, startedAtLt?: string, startedAtLte?: string, startedAtRange?: Array<string>, state?: 'canceled' | 'canceling' | 'completed' | 'failed' | 'running' | 'skipped' | 'waiting', stateIn?: Array<string>, taskGroup?: string, worker?: string, workerIn?: Array<string>, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedTaskResponseList> {
            return localVarFp.list(childTasks, createdResources, finishedAt, finishedAtGt, finishedAtGte, finishedAtLt, finishedAtLte, finishedAtRange, limit, loggingCid, loggingCidContains, name, nameContains, offset, ordering, parentTask, reservedResourcesRecord, startedAt, startedAtGt, startedAtGte, startedAtLt, startedAtLte, startedAtRange, state, stateIn, taskGroup, worker, workerIn, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a task
         * @param {string} taskHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(taskHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<TaskResponse> {
            return localVarFp.read(taskHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation cancels a task.
         * @summary Cancel a task
         * @param {string} taskHref 
         * @param {PatchedTaskCancel} patchedTaskCancel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCancel(taskHref: string, patchedTaskCancel: PatchedTaskCancel, options?: any): AxiosPromise<TaskResponse> {
            return localVarFp.tasksCancel(taskHref, patchedTaskCancel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary Delete a task
     * @param {string} taskHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public _delete(taskHref: string, options?: any) {
        return TasksApiFp(this.configuration)._delete(taskHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary List tasks
     * @param {string} [childTasks] Foreign Key referenced by HREF
     * @param {string} [createdResources] 
     * @param {string} [finishedAt] ISO 8601 formatted dates are supported
     * @param {string} [finishedAtGt] Filter results where finished_at is greater than value
     * @param {string} [finishedAtGte] Filter results where finished_at is greater than or equal to value
     * @param {string} [finishedAtLt] Filter results where finished_at is less than value
     * @param {string} [finishedAtLte] Filter results where finished_at is less than or equal to value
     * @param {Array<string>} [finishedAtRange] Filter results where finished_at is between two comma separated values
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [loggingCid] 
     * @param {string} [loggingCidContains] Filter results where logging_cid contains value
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [parentTask] Foreign Key referenced by HREF
     * @param {Array<string>} [reservedResourcesRecord] 
     * @param {string} [startedAt] ISO 8601 formatted dates are supported
     * @param {string} [startedAtGt] Filter results where started_at is greater than value
     * @param {string} [startedAtGte] Filter results where started_at is greater than or equal to value
     * @param {string} [startedAtLt] Filter results where started_at is less than value
     * @param {string} [startedAtLte] Filter results where started_at is less than or equal to value
     * @param {Array<string>} [startedAtRange] Filter results where started_at is between two comma separated values
     * @param {'canceled' | 'canceling' | 'completed' | 'failed' | 'running' | 'skipped' | 'waiting'} [state] 
     * @param {Array<string>} [stateIn] Filter results where state is in a comma-separated list of values
     * @param {string} [taskGroup] Foreign Key referenced by HREF
     * @param {string} [worker] Foreign Key referenced by HREF
     * @param {Array<string>} [workerIn] Filter results where worker is in a comma-separated list of values
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public list(childTasks?: string, createdResources?: string, finishedAt?: string, finishedAtGt?: string, finishedAtGte?: string, finishedAtLt?: string, finishedAtLte?: string, finishedAtRange?: Array<string>, limit?: number, loggingCid?: string, loggingCidContains?: string, name?: string, nameContains?: string, offset?: number, ordering?: string, parentTask?: string, reservedResourcesRecord?: Array<string>, startedAt?: string, startedAtGt?: string, startedAtGte?: string, startedAtLt?: string, startedAtLte?: string, startedAtRange?: Array<string>, state?: 'canceled' | 'canceling' | 'completed' | 'failed' | 'running' | 'skipped' | 'waiting', stateIn?: Array<string>, taskGroup?: string, worker?: string, workerIn?: Array<string>, fields?: string, excludeFields?: string, options?: any) {
        return TasksApiFp(this.configuration).list(childTasks, createdResources, finishedAt, finishedAtGt, finishedAtGte, finishedAtLt, finishedAtLte, finishedAtRange, limit, loggingCid, loggingCidContains, name, nameContains, offset, ordering, parentTask, reservedResourcesRecord, startedAt, startedAtGt, startedAtGte, startedAtLt, startedAtLte, startedAtRange, state, stateIn, taskGroup, worker, workerIn, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary Inspect a task
     * @param {string} taskHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public read(taskHref: string, fields?: string, excludeFields?: string, options?: any) {
        return TasksApiFp(this.configuration).read(taskHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation cancels a task.
     * @summary Cancel a task
     * @param {string} taskHref 
     * @param {PatchedTaskCancel} patchedTaskCancel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCancel(taskHref: string, patchedTaskCancel: PatchedTaskCancel, options?: any) {
        return TasksApiFp(this.configuration).tasksCancel(taskHref, patchedTaskCancel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadsApi - axios parameter creator
 * @export
 */
export const UploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * View for chunked uploads.
         * @summary Delete an upload
         * @param {string} uploadHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (uploadHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadHref' is not null or undefined
            assertParamExists('_delete', 'uploadHref', uploadHref)
            const localVarPath = `{upload_href}`
                .replace(`{${"upload_href"}}`, String(uploadHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queues a Task that creates an Artifact, and the Upload gets deleted and cannot be re-used.
         * @summary Finish an Upload
         * @param {string} uploadHref 
         * @param {UploadCommit} uploadCommit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit: async (uploadHref: string, uploadCommit: UploadCommit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadHref' is not null or undefined
            assertParamExists('commit', 'uploadHref', uploadHref)
            // verify required parameter 'uploadCommit' is not null or undefined
            assertParamExists('commit', 'uploadCommit', uploadCommit)
            const localVarPath = `{upload_href}commit/`
                .replace(`{${"upload_href"}}`, String(uploadHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadCommit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View for chunked uploads.
         * @summary Create an upload
         * @param {Upload} upload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (upload: Upload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'upload' is not null or undefined
            assertParamExists('create', 'upload', upload)
            const localVarPath = `/pulp/api/v3/uploads/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View for chunked uploads.
         * @summary List uploads
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/uploads/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View for chunked uploads.
         * @summary Inspect an upload
         * @param {string} uploadHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (uploadHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadHref' is not null or undefined
            assertParamExists('read', 'uploadHref', uploadHref)
            const localVarPath = `{upload_href}`
                .replace(`{${"upload_href"}}`, String(uploadHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a chunk for an upload.
         * @summary Upload a file chunk
         * @param {string} contentRange The Content-Range header specifies the location of the file chunk within the file.
         * @param {string} uploadHref 
         * @param {any} file A chunk of the uploaded file.
         * @param {string} [sha256] The SHA-256 checksum of the chunk if available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (contentRange: string, uploadHref: string, file: any, sha256?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentRange' is not null or undefined
            assertParamExists('update', 'contentRange', contentRange)
            // verify required parameter 'uploadHref' is not null or undefined
            assertParamExists('update', 'uploadHref', uploadHref)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('update', 'file', file)
            const localVarPath = `{upload_href}`
                .replace(`{${"upload_href"}}`, String(uploadHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (contentRange !== undefined && contentRange !== null) {
                localVarHeaderParameter['Content-Range'] = String(contentRange);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (sha256 !== undefined) { 
                localVarFormParams.append('sha256', sha256 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsApi - functional programming interface
 * @export
 */
export const UploadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadsApiAxiosParamCreator(configuration)
    return {
        /**
         * View for chunked uploads.
         * @summary Delete an upload
         * @param {string} uploadHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(uploadHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(uploadHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queues a Task that creates an Artifact, and the Upload gets deleted and cannot be re-used.
         * @summary Finish an Upload
         * @param {string} uploadHref 
         * @param {UploadCommit} uploadCommit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commit(uploadHref: string, uploadCommit: UploadCommit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commit(uploadHref, uploadCommit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View for chunked uploads.
         * @summary Create an upload
         * @param {Upload} upload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(upload: Upload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(upload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View for chunked uploads.
         * @summary List uploads
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUploadResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View for chunked uploads.
         * @summary Inspect an upload
         * @param {string} uploadHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(uploadHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(uploadHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload a chunk for an upload.
         * @summary Upload a file chunk
         * @param {string} contentRange The Content-Range header specifies the location of the file chunk within the file.
         * @param {string} uploadHref 
         * @param {any} file A chunk of the uploaded file.
         * @param {string} [sha256] The SHA-256 checksum of the chunk if available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(contentRange: string, uploadHref: string, file: any, sha256?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(contentRange, uploadHref, file, sha256, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UploadsApi - factory interface
 * @export
 */
export const UploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadsApiFp(configuration)
    return {
        /**
         * View for chunked uploads.
         * @summary Delete an upload
         * @param {string} uploadHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(uploadHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(uploadHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Queues a Task that creates an Artifact, and the Upload gets deleted and cannot be re-used.
         * @summary Finish an Upload
         * @param {string} uploadHref 
         * @param {UploadCommit} uploadCommit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(uploadHref: string, uploadCommit: UploadCommit, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.commit(uploadHref, uploadCommit, options).then((request) => request(axios, basePath));
        },
        /**
         * View for chunked uploads.
         * @summary Create an upload
         * @param {Upload} upload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(upload: Upload, options?: any): AxiosPromise<UploadResponse> {
            return localVarFp.create(upload, options).then((request) => request(axios, basePath));
        },
        /**
         * View for chunked uploads.
         * @summary List uploads
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedUploadResponseList> {
            return localVarFp.list(limit, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * View for chunked uploads.
         * @summary Inspect an upload
         * @param {string} uploadHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(uploadHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<UploadDetailResponse> {
            return localVarFp.read(uploadHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a chunk for an upload.
         * @summary Upload a file chunk
         * @param {string} contentRange The Content-Range header specifies the location of the file chunk within the file.
         * @param {string} uploadHref 
         * @param {any} file A chunk of the uploaded file.
         * @param {string} [sha256] The SHA-256 checksum of the chunk if available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(contentRange: string, uploadHref: string, file: any, sha256?: string, options?: any): AxiosPromise<UploadResponse> {
            return localVarFp.update(contentRange, uploadHref, file, sha256, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadsApi - object-oriented interface
 * @export
 * @class UploadsApi
 * @extends {BaseAPI}
 */
export class UploadsApi extends BaseAPI {
    /**
     * View for chunked uploads.
     * @summary Delete an upload
     * @param {string} uploadHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public _delete(uploadHref: string, options?: any) {
        return UploadsApiFp(this.configuration)._delete(uploadHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queues a Task that creates an Artifact, and the Upload gets deleted and cannot be re-used.
     * @summary Finish an Upload
     * @param {string} uploadHref 
     * @param {UploadCommit} uploadCommit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public commit(uploadHref: string, uploadCommit: UploadCommit, options?: any) {
        return UploadsApiFp(this.configuration).commit(uploadHref, uploadCommit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View for chunked uploads.
     * @summary Create an upload
     * @param {Upload} upload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public create(upload: Upload, options?: any) {
        return UploadsApiFp(this.configuration).create(upload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View for chunked uploads.
     * @summary List uploads
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public list(limit?: number, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return UploadsApiFp(this.configuration).list(limit, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View for chunked uploads.
     * @summary Inspect an upload
     * @param {string} uploadHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public read(uploadHref: string, fields?: string, excludeFields?: string, options?: any) {
        return UploadsApiFp(this.configuration).read(uploadHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a chunk for an upload.
     * @summary Upload a file chunk
     * @param {string} contentRange The Content-Range header specifies the location of the file chunk within the file.
     * @param {string} uploadHref 
     * @param {any} file A chunk of the uploaded file.
     * @param {string} [sha256] The SHA-256 checksum of the chunk if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public update(contentRange: string, uploadHref: string, file: any, sha256?: string, options?: any) {
        return UploadsApiFp(this.configuration).update(contentRange, uploadHref, file, sha256, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List users
         * @param {string} [email] Filter results where email matches value
         * @param {string} [emailContains] Filter results where email contains value
         * @param {string} [emailIcontains] Filter results where email contains value
         * @param {string} [emailIexact] Filter results where email matches value
         * @param {Array<string>} [emailIn] Filter results where email is in a comma-separated list of values
         * @param {string} [firstName] Filter results where first_name matches value
         * @param {string} [firstNameContains] Filter results where first_name contains value
         * @param {string} [firstNameIcontains] Filter results where first_name contains value
         * @param {string} [firstNameIexact] Filter results where first_name matches value
         * @param {Array<string>} [firstNameIn] Filter results where first_name is in a comma-separated list of values
         * @param {boolean} [isActive] Filter results where is_active matches value
         * @param {boolean} [isStaff] Filter results where is_staff matches value
         * @param {string} [lastName] Filter results where last_name matches value
         * @param {string} [lastNameContains] Filter results where last_name contains value
         * @param {string} [lastNameIcontains] Filter results where last_name contains value
         * @param {string} [lastNameIexact] Filter results where last_name matches value
         * @param {Array<string>} [lastNameIn] Filter results where last_name is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [username] Filter results where username matches value
         * @param {string} [usernameContains] Filter results where username contains value
         * @param {string} [usernameIcontains] Filter results where username contains value
         * @param {string} [usernameIexact] Filter results where username matches value
         * @param {Array<string>} [usernameIn] Filter results where username is in a comma-separated list of values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (email?: string, emailContains?: string, emailIcontains?: string, emailIexact?: string, emailIn?: Array<string>, firstName?: string, firstNameContains?: string, firstNameIcontains?: string, firstNameIexact?: string, firstNameIn?: Array<string>, isActive?: boolean, isStaff?: boolean, lastName?: string, lastNameContains?: string, lastNameIcontains?: string, lastNameIexact?: string, lastNameIn?: Array<string>, limit?: number, offset?: number, ordering?: string, username?: string, usernameContains?: string, usernameIcontains?: string, usernameIexact?: string, usernameIn?: Array<string>, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (emailContains !== undefined) {
                localVarQueryParameter['email__contains'] = emailContains;
            }

            if (emailIcontains !== undefined) {
                localVarQueryParameter['email__icontains'] = emailIcontains;
            }

            if (emailIexact !== undefined) {
                localVarQueryParameter['email__iexact'] = emailIexact;
            }

            if (emailIn) {
                localVarQueryParameter['email__in'] = emailIn.join(COLLECTION_FORMATS.csv);
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first_name'] = firstName;
            }

            if (firstNameContains !== undefined) {
                localVarQueryParameter['first_name__contains'] = firstNameContains;
            }

            if (firstNameIcontains !== undefined) {
                localVarQueryParameter['first_name__icontains'] = firstNameIcontains;
            }

            if (firstNameIexact !== undefined) {
                localVarQueryParameter['first_name__iexact'] = firstNameIexact;
            }

            if (firstNameIn) {
                localVarQueryParameter['first_name__in'] = firstNameIn.join(COLLECTION_FORMATS.csv);
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (isStaff !== undefined) {
                localVarQueryParameter['is_staff'] = isStaff;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['last_name'] = lastName;
            }

            if (lastNameContains !== undefined) {
                localVarQueryParameter['last_name__contains'] = lastNameContains;
            }

            if (lastNameIcontains !== undefined) {
                localVarQueryParameter['last_name__icontains'] = lastNameIcontains;
            }

            if (lastNameIexact !== undefined) {
                localVarQueryParameter['last_name__iexact'] = lastNameIexact;
            }

            if (lastNameIn) {
                localVarQueryParameter['last_name__in'] = lastNameIn.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (usernameContains !== undefined) {
                localVarQueryParameter['username__contains'] = usernameContains;
            }

            if (usernameIcontains !== undefined) {
                localVarQueryParameter['username__icontains'] = usernameIcontains;
            }

            if (usernameIexact !== undefined) {
                localVarQueryParameter['username__iexact'] = usernameIexact;
            }

            if (usernameIn) {
                localVarQueryParameter['username__in'] = usernameIn.join(COLLECTION_FORMATS.csv);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List user permissions.
         * @param {string} authUserHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissions: async (authUserHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authUserHref' is not null or undefined
            assertParamExists('permissions', 'authUserHref', authUserHref)
            const localVarPath = `{auth_user_href}permissions/`
                .replace(`{${"auth_user_href"}}`, String(authUserHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect an user
         * @param {string} authUserHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (authUserHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authUserHref' is not null or undefined
            assertParamExists('read', 'authUserHref', authUserHref)
            const localVarPath = `{auth_user_href}`
                .replace(`{${"auth_user_href"}}`, String(authUserHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List users
         * @param {string} [email] Filter results where email matches value
         * @param {string} [emailContains] Filter results where email contains value
         * @param {string} [emailIcontains] Filter results where email contains value
         * @param {string} [emailIexact] Filter results where email matches value
         * @param {Array<string>} [emailIn] Filter results where email is in a comma-separated list of values
         * @param {string} [firstName] Filter results where first_name matches value
         * @param {string} [firstNameContains] Filter results where first_name contains value
         * @param {string} [firstNameIcontains] Filter results where first_name contains value
         * @param {string} [firstNameIexact] Filter results where first_name matches value
         * @param {Array<string>} [firstNameIn] Filter results where first_name is in a comma-separated list of values
         * @param {boolean} [isActive] Filter results where is_active matches value
         * @param {boolean} [isStaff] Filter results where is_staff matches value
         * @param {string} [lastName] Filter results where last_name matches value
         * @param {string} [lastNameContains] Filter results where last_name contains value
         * @param {string} [lastNameIcontains] Filter results where last_name contains value
         * @param {string} [lastNameIexact] Filter results where last_name matches value
         * @param {Array<string>} [lastNameIn] Filter results where last_name is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [username] Filter results where username matches value
         * @param {string} [usernameContains] Filter results where username contains value
         * @param {string} [usernameIcontains] Filter results where username contains value
         * @param {string} [usernameIexact] Filter results where username matches value
         * @param {Array<string>} [usernameIn] Filter results where username is in a comma-separated list of values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(email?: string, emailContains?: string, emailIcontains?: string, emailIexact?: string, emailIn?: Array<string>, firstName?: string, firstNameContains?: string, firstNameIcontains?: string, firstNameIexact?: string, firstNameIn?: Array<string>, isActive?: boolean, isStaff?: boolean, lastName?: string, lastNameContains?: string, lastNameIcontains?: string, lastNameIexact?: string, lastNameIn?: Array<string>, limit?: number, offset?: number, ordering?: string, username?: string, usernameContains?: string, usernameIcontains?: string, usernameIexact?: string, usernameIn?: Array<string>, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(email, emailContains, emailIcontains, emailIexact, emailIn, firstName, firstNameContains, firstNameIcontains, firstNameIexact, firstNameIn, isActive, isStaff, lastName, lastNameContains, lastNameIcontains, lastNameIexact, lastNameIn, limit, offset, ordering, username, usernameContains, usernameIcontains, usernameIexact, usernameIn, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List user permissions.
         * @param {string} authUserHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissions(authUserHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissions(authUserHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect an user
         * @param {string} authUserHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(authUserHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(authUserHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary List users
         * @param {string} [email] Filter results where email matches value
         * @param {string} [emailContains] Filter results where email contains value
         * @param {string} [emailIcontains] Filter results where email contains value
         * @param {string} [emailIexact] Filter results where email matches value
         * @param {Array<string>} [emailIn] Filter results where email is in a comma-separated list of values
         * @param {string} [firstName] Filter results where first_name matches value
         * @param {string} [firstNameContains] Filter results where first_name contains value
         * @param {string} [firstNameIcontains] Filter results where first_name contains value
         * @param {string} [firstNameIexact] Filter results where first_name matches value
         * @param {Array<string>} [firstNameIn] Filter results where first_name is in a comma-separated list of values
         * @param {boolean} [isActive] Filter results where is_active matches value
         * @param {boolean} [isStaff] Filter results where is_staff matches value
         * @param {string} [lastName] Filter results where last_name matches value
         * @param {string} [lastNameContains] Filter results where last_name contains value
         * @param {string} [lastNameIcontains] Filter results where last_name contains value
         * @param {string} [lastNameIexact] Filter results where last_name matches value
         * @param {Array<string>} [lastNameIn] Filter results where last_name is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [username] Filter results where username matches value
         * @param {string} [usernameContains] Filter results where username contains value
         * @param {string} [usernameIcontains] Filter results where username contains value
         * @param {string} [usernameIexact] Filter results where username matches value
         * @param {Array<string>} [usernameIn] Filter results where username is in a comma-separated list of values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(email?: string, emailContains?: string, emailIcontains?: string, emailIexact?: string, emailIn?: Array<string>, firstName?: string, firstNameContains?: string, firstNameIcontains?: string, firstNameIexact?: string, firstNameIn?: Array<string>, isActive?: boolean, isStaff?: boolean, lastName?: string, lastNameContains?: string, lastNameIcontains?: string, lastNameIexact?: string, lastNameIn?: Array<string>, limit?: number, offset?: number, ordering?: string, username?: string, usernameContains?: string, usernameIcontains?: string, usernameIexact?: string, usernameIn?: Array<string>, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedUserResponseList> {
            return localVarFp.list(email, emailContains, emailIcontains, emailIexact, emailIn, firstName, firstNameContains, firstNameIcontains, firstNameIexact, firstNameIn, isActive, isStaff, lastName, lastNameContains, lastNameIcontains, lastNameIexact, lastNameIn, limit, offset, ordering, username, usernameContains, usernameIcontains, usernameIexact, usernameIn, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * List user permissions.
         * @param {string} authUserHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissions(authUserHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.permissions(authUserHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
         * @summary Inspect an user
         * @param {string} authUserHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(authUserHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.read(authUserHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary List users
     * @param {string} [email] Filter results where email matches value
     * @param {string} [emailContains] Filter results where email contains value
     * @param {string} [emailIcontains] Filter results where email contains value
     * @param {string} [emailIexact] Filter results where email matches value
     * @param {Array<string>} [emailIn] Filter results where email is in a comma-separated list of values
     * @param {string} [firstName] Filter results where first_name matches value
     * @param {string} [firstNameContains] Filter results where first_name contains value
     * @param {string} [firstNameIcontains] Filter results where first_name contains value
     * @param {string} [firstNameIexact] Filter results where first_name matches value
     * @param {Array<string>} [firstNameIn] Filter results where first_name is in a comma-separated list of values
     * @param {boolean} [isActive] Filter results where is_active matches value
     * @param {boolean} [isStaff] Filter results where is_staff matches value
     * @param {string} [lastName] Filter results where last_name matches value
     * @param {string} [lastNameContains] Filter results where last_name contains value
     * @param {string} [lastNameIcontains] Filter results where last_name contains value
     * @param {string} [lastNameIexact] Filter results where last_name matches value
     * @param {Array<string>} [lastNameIn] Filter results where last_name is in a comma-separated list of values
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [username] Filter results where username matches value
     * @param {string} [usernameContains] Filter results where username contains value
     * @param {string} [usernameIcontains] Filter results where username contains value
     * @param {string} [usernameIexact] Filter results where username matches value
     * @param {Array<string>} [usernameIn] Filter results where username is in a comma-separated list of values
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public list(email?: string, emailContains?: string, emailIcontains?: string, emailIexact?: string, emailIn?: Array<string>, firstName?: string, firstNameContains?: string, firstNameIcontains?: string, firstNameIexact?: string, firstNameIn?: Array<string>, isActive?: boolean, isStaff?: boolean, lastName?: string, lastNameContains?: string, lastNameIcontains?: string, lastNameIexact?: string, lastNameIn?: Array<string>, limit?: number, offset?: number, ordering?: string, username?: string, usernameContains?: string, usernameIcontains?: string, usernameIexact?: string, usernameIn?: Array<string>, fields?: string, excludeFields?: string, options?: any) {
        return UsersApiFp(this.configuration).list(email, emailContains, emailIcontains, emailIexact, emailIn, firstName, firstNameContains, firstNameIcontains, firstNameIexact, firstNameIn, isActive, isStaff, lastName, lastNameContains, lastNameIcontains, lastNameIexact, lastNameIn, limit, offset, ordering, username, usernameContains, usernameIcontains, usernameIexact, usernameIn, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List user permissions.
     * @param {string} authUserHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public permissions(authUserHref: string, fields?: string, excludeFields?: string, options?: any) {
        return UsersApiFp(this.configuration).permissions(authUserHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for User.  NOTE: This API endpoint is in \"tech preview\" and subject to change
     * @summary Inspect an user
     * @param {string} authUserHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public read(authUserHref: string, fields?: string, excludeFields?: string, options?: any) {
        return UsersApiFp(this.configuration).read(authUserHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkersApi - axios parameter creator
 * @export
 */
export const WorkersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List workers
         * @param {string} [lastHeartbeat] ISO 8601 formatted dates are supported
         * @param {string} [lastHeartbeatGt] Filter results where last_heartbeat is greater than value
         * @param {string} [lastHeartbeatGte] Filter results where last_heartbeat is greater than or equal to value
         * @param {string} [lastHeartbeatLt] Filter results where last_heartbeat is less than value
         * @param {string} [lastHeartbeatLte] Filter results where last_heartbeat is less than or equal to value
         * @param {Array<string>} [lastHeartbeatRange] Filter results where last_heartbeat is between two comma separated values
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [missing] 
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {boolean} [online] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (lastHeartbeat?: string, lastHeartbeatGt?: string, lastHeartbeatGte?: string, lastHeartbeatLt?: string, lastHeartbeatLte?: string, lastHeartbeatRange?: Array<string>, limit?: number, missing?: boolean, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, online?: boolean, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/workers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (lastHeartbeat !== undefined) {
                localVarQueryParameter['last_heartbeat'] = (lastHeartbeat as any instanceof Date) ?
                    (lastHeartbeat as any).toISOString() :
                    lastHeartbeat;
            }

            if (lastHeartbeatGt !== undefined) {
                localVarQueryParameter['last_heartbeat__gt'] = (lastHeartbeatGt as any instanceof Date) ?
                    (lastHeartbeatGt as any).toISOString() :
                    lastHeartbeatGt;
            }

            if (lastHeartbeatGte !== undefined) {
                localVarQueryParameter['last_heartbeat__gte'] = (lastHeartbeatGte as any instanceof Date) ?
                    (lastHeartbeatGte as any).toISOString() :
                    lastHeartbeatGte;
            }

            if (lastHeartbeatLt !== undefined) {
                localVarQueryParameter['last_heartbeat__lt'] = (lastHeartbeatLt as any instanceof Date) ?
                    (lastHeartbeatLt as any).toISOString() :
                    lastHeartbeatLt;
            }

            if (lastHeartbeatLte !== undefined) {
                localVarQueryParameter['last_heartbeat__lte'] = (lastHeartbeatLte as any instanceof Date) ?
                    (lastHeartbeatLte as any).toISOString() :
                    lastHeartbeatLte;
            }

            if (lastHeartbeatRange) {
                localVarQueryParameter['last_heartbeat__range'] = lastHeartbeatRange.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (missing !== undefined) {
                localVarQueryParameter['missing'] = missing;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (online !== undefined) {
                localVarQueryParameter['online'] = online;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a worker
         * @param {string} workerHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (workerHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerHref' is not null or undefined
            assertParamExists('read', 'workerHref', workerHref)
            const localVarPath = `{worker_href}`
                .replace(`{${"worker_href"}}`, String(workerHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkersApi - functional programming interface
 * @export
 */
export const WorkersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkersApiAxiosParamCreator(configuration)
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List workers
         * @param {string} [lastHeartbeat] ISO 8601 formatted dates are supported
         * @param {string} [lastHeartbeatGt] Filter results where last_heartbeat is greater than value
         * @param {string} [lastHeartbeatGte] Filter results where last_heartbeat is greater than or equal to value
         * @param {string} [lastHeartbeatLt] Filter results where last_heartbeat is less than value
         * @param {string} [lastHeartbeatLte] Filter results where last_heartbeat is less than or equal to value
         * @param {Array<string>} [lastHeartbeatRange] Filter results where last_heartbeat is between two comma separated values
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [missing] 
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {boolean} [online] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(lastHeartbeat?: string, lastHeartbeatGt?: string, lastHeartbeatGte?: string, lastHeartbeatLt?: string, lastHeartbeatLte?: string, lastHeartbeatRange?: Array<string>, limit?: number, missing?: boolean, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, online?: boolean, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWorkerResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(lastHeartbeat, lastHeartbeatGt, lastHeartbeatGte, lastHeartbeatLt, lastHeartbeatLte, lastHeartbeatRange, limit, missing, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, online, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a worker
         * @param {string} workerHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(workerHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(workerHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkersApi - factory interface
 * @export
 */
export const WorkersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkersApiFp(configuration)
    return {
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary List workers
         * @param {string} [lastHeartbeat] ISO 8601 formatted dates are supported
         * @param {string} [lastHeartbeatGt] Filter results where last_heartbeat is greater than value
         * @param {string} [lastHeartbeatGte] Filter results where last_heartbeat is greater than or equal to value
         * @param {string} [lastHeartbeatLt] Filter results where last_heartbeat is less than value
         * @param {string} [lastHeartbeatLte] Filter results where last_heartbeat is less than or equal to value
         * @param {Array<string>} [lastHeartbeatRange] Filter results where last_heartbeat is between two comma separated values
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [missing] 
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {boolean} [online] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(lastHeartbeat?: string, lastHeartbeatGt?: string, lastHeartbeatGte?: string, lastHeartbeatLt?: string, lastHeartbeatLte?: string, lastHeartbeatRange?: Array<string>, limit?: number, missing?: boolean, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, online?: boolean, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedWorkerResponseList> {
            return localVarFp.list(lastHeartbeat, lastHeartbeatGt, lastHeartbeatGte, lastHeartbeatLt, lastHeartbeatLte, lastHeartbeatRange, limit, missing, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, online, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
         * @summary Inspect a worker
         * @param {string} workerHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(workerHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<WorkerResponse> {
            return localVarFp.read(workerHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkersApi - object-oriented interface
 * @export
 * @class WorkersApi
 * @extends {BaseAPI}
 */
export class WorkersApi extends BaseAPI {
    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary List workers
     * @param {string} [lastHeartbeat] ISO 8601 formatted dates are supported
     * @param {string} [lastHeartbeatGt] Filter results where last_heartbeat is greater than value
     * @param {string} [lastHeartbeatGte] Filter results where last_heartbeat is greater than or equal to value
     * @param {string} [lastHeartbeatLt] Filter results where last_heartbeat is less than value
     * @param {string} [lastHeartbeatLte] Filter results where last_heartbeat is less than or equal to value
     * @param {Array<string>} [lastHeartbeatRange] Filter results where last_heartbeat is between two comma separated values
     * @param {number} [limit] Number of results to return per page.
     * @param {boolean} [missing] 
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {boolean} [online] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersApi
     */
    public list(lastHeartbeat?: string, lastHeartbeatGt?: string, lastHeartbeatGte?: string, lastHeartbeatLt?: string, lastHeartbeatLte?: string, lastHeartbeatRange?: Array<string>, limit?: number, missing?: boolean, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, online?: boolean, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return WorkersApiFp(this.configuration).list(lastHeartbeat, lastHeartbeatGt, lastHeartbeatGte, lastHeartbeatLt, lastHeartbeatLte, lastHeartbeatRange, limit, missing, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, online, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A customized named ModelViewSet that knows how to register itself with the Pulp API router.  This viewset is discoverable by its name. \"Normal\" Django Models and Master/Detail models are supported by the ``register_with`` method.  Attributes:     lookup_field (str): The name of the field by which an object should be looked up, in         addition to any parent lookups if this ViewSet is nested. Defaults to \'pk\'     endpoint_name (str): The name of the final path segment that should identify the ViewSet\'s         collection endpoint.     nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must         correspond to the \"parent_prefix\" of a router with rest_framework_nested.NestedMixin.         None indicates this ViewSet should not be nested.     parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs         to django model filter expressions that can be used with the corresponding value from         self.kwargs, used only by a nested ViewSet to filter based on the parent object\'s         identity.     schema (DefaultSchema): The schema class to use by default in a viewset.
     * @summary Inspect a worker
     * @param {string} workerHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersApi
     */
    public read(workerHref: string, fields?: string, excludeFields?: string, options?: any) {
        return WorkersApiFp(this.configuration).read(workerHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



